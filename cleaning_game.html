<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="/favicon.png" type="image/png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reinigungskraft - Erbs-Schafts-Spiel</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a; /* Darker grey for contrast */
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        #canvas-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            min-height: 100vh;
            background: #2a2a2a; /* Canvas background color */
        }
        canvas {
            display: block;
            background: #2a2a2a;
            width: 100%;
            max-width: 800px;
        }
        #top-bar {
            display: none;
        }
        #controls {
            position: fixed;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            z-index: 100;
            font-size: 12px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            margin: 2px;
        }
        button:hover { background: #45a049; }
        #scroll-indicator {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translate3d(-50%, 0, 0);
            width: min(80vw, 460px);
            background: rgba(0, 0, 0, 0.72);
            color: #FFD700;
            padding: 14px;
            border-radius: 16px;
            font-size: clamp(14px, 4vw, 16px);
            font-weight: 500;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(10px);
            text-align: center;
            opacity: 1;
            transition: opacity 0.45s ease, transform 0.45s ease;
            will-change: opacity, transform;
        }
        #scroll-indicator.hidden {
            opacity: 0;
            transform: translate3d(-50%, -24px, 0);
        }

        @media (max-width: 480px) {

        }
        #tax-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 200;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        #tax-popup.visible {
            display: block;
            animation: popupAppear 0.3s ease-out;
        }
        @keyframes popupAppear {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        #tax-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 199;
        }
        #tax-overlay.visible {
            display: block;
        }
        #tax-popup h2 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 24px;
        }
        #tax-popup p {
            margin: 0 0 20px 0;
            color: #666;
            line-height: 1.5;
        }
        #tax-popup button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 30px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
        }
        #tax-popup button:hover {
            background: #45a049;
        }

        #tax-popup button.no-button {
            background: #ae0c00;
            color: white;
            border: none;
            padding: 12px 30px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
        }
        #tax-popup button.no-button:hover {
            background: #ae0c00;
        }
 
        #achievement-alert {
            position: fixed;
            left: 20px;
            bottom: 20px;
            background: rgba(15, 15, 15, 0.92);
            color: #fff;
            padding: 16px 20px;
            border-radius: 14px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
            display: flex;
            align-items: center;
            gap: 14px;
            transform: translateY(140%);
            opacity: 0;
            transition: transform 0.4s ease, opacity 0.4s ease;
            z-index: 205;
            pointer-events: none;
            font-family: 'Arial', sans-serif;
        }
        #achievement-alert.visible {
            transform: translateY(0);
            opacity: 1;
        }
        #achievement-alert .achievement-icon {
            font-size: 32px;
        }
        #achievement-alert .achievement-content {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
        }
        #achievement-alert .achievement-title {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 4px;
            color: #FFD54F;
        }
        #achievement-alert .achievement-text {
            font-size: 14px;
            color: #f0f0f0;
        }
 
        #gameover-overlay {

            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 250;
        }
        #gameover-overlay.visible {
            display: block;
        }
        #gameover-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1f1f1f;
            color: #fff;
            padding: 32px;
            border-radius: 18px;
            width: min(420px, 90%);
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            z-index: 251;

            border: 2px solid #ff6f61;   /* NEW: subtle red frame */
            animation: popupAppear 0.35s ease-out; /* Reuse your existing popup animation */
        }
        #gameover-popup.visible {
            display: block;
            animation: popupAppear 0.35s ease-out;
        }
        #gameover-popup h2 {
            margin-top: 0;
            font-size: 26px;
            color: #ff6f61;
        }
        #gameover-popup p {
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 24px;
            color: #d7d7d7;
        }
        #gameover-popup button {
            background: #ff6f61;
            border: none;
            color: #1f1f1f;
            font-weight: bold;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.2s ease, background 0.2s ease;
            width: 100%;
        }
        #gameover-popup button:hover {
            background: #ff8a7b;
            transform: translateY(-1px);
        }
        #gameover-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            text-align: left;
        }

        .tutorial-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: clamp(16px, 4vw, 48px);
            z-index: 150;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .tutorial-overlay.visible {
            opacity: 1;
        }
        .tutorial-overlay .tutorial-card {
            width: min(520px, 100%);
            background: rgba(0, 0, 0, 0.82);
            border: 2px solid #4CAF50;
            border-radius: 18px;
            padding: clamp(10px, 2.0vw, 16px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.45);
            color: #ffffff;
            text-align: center;
            transform: translateY(10px) scale(0.95);
            transition: transform 0.3s ease;
        }
        .tutorial-overlay.visible .tutorial-card {
            transform: translateY(0) scale(1);
        }
        .tutorial-overlay .tutorial-icon {
            font-size: clamp(32px, 6vw, 48px);
            margin-bottom: 12px;
        }
        .tutorial-overlay .tutorial-text p {
            margin: clamp(16px, 4vw, 20px);
            font-size: clamp(16px, 4vw, 20px);
            line-height: 1.4;
        }

    </style>

</head>
<body>
    <div id="canvas-container"><canvas id="canvas"></canvas></div>

    <div id="top-bar">
        <div id="year-display">Jahr 1</div>
        <div id="money-display">0.-</div>
    </div>


    <div id="scroll-indicator" class="hidden">Nach oben scrollen um deinen ganzen Reichtum zu entdecken</div>
    
    <div id="tutorial-overlay" class="tutorial-overlay" aria-hidden="true" aria-live="polite">
        <div class="tutorial-card">
            <div class="tutorial-icon" id="tutorial-icon">üßΩ</div>
            <div class="tutorial-text" id="tutorial-text"></div>
        </div>
    </div>

    <div id="achievement-alert" aria-live="polite">
        <div class="achievement-icon">üèÜ</div>
        <div class="achievement-content">
            <div class="achievement-title">Spongebob Schwammkopf</div>
            <div class="achievement-text">Du schrubbst schneller als dein Schatten</div>
        </div>
    </div>
    
    <div id="tax-overlay"></div>
    <div id="tax-popup">
        <h2 id="tax-popup-title">üèõÔ∏è Steueramt</h2>
        <p id="tax-popup-text"></p>
        <button id="tax-popup-button"></button>
    </div>

    <div id="gameover-popup">
        <h2>Zahlungsverzug</h2>

        <p id="mahnung-text" style="color:#d7d7d7; font-size:16px; line-height:1.4; margin-bottom:22px;">
            Auf was verzichtest du, um die Rechnung plus Mahngeb√ºren zu bezahlen?
        </p>

        <div id="gameover-options">
            <button class="gameover-option" data-choice="restaurant">Restaurantbesuch</button>
            <button class="gameover-option" data-choice="kids">Ausflug mit Kindern</button>
            <button class="gameover-option" data-choice="bio">Teureres Bio-Gem√ºse</button>
        </div>
    </div>


    
    <button id="restart-btn" style="visibility: hidden; opacity:0; transition:opacity 0.8s ease; position: fixed; bottom: 20px; left: calc(50% - 115px); z-index: 300; background: rgba(26, 26, 26, 0.6); color: white; border: none; width: 105px; padding: 10px; cursor: pointer; border-radius: 10px; font-size: 14px; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">Hauptmen√º</button>
    <button id="info-btn" style="visibility: hidden; opacity:0; transition:opacity 0.8s ease; position: fixed; bottom: 20px; right: calc(50% - 115px); z-index: 300; background: rgba(26, 26, 26, 0.6); color: white; border: none; width: 105px; padding: 10px; cursor: pointer; border-radius: 10px; font-size: 14px; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">Mehr Info</button>


    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const scrollIndicator = document.getElementById('scroll-indicator');
        const tutorialOverlay = document.getElementById('tutorial-overlay');
        const tutorialText = document.getElementById('tutorial-text');
        const tutorialIcon = document.getElementById('tutorial-icon');
        const gameOverOverlay = document.getElementById('gameover-overlay');
        const gameOverPopup = document.getElementById('gameover-popup');
        const gameOverOptions = document.querySelectorAll('.gameover-option');
        const achievementAlert = document.getElementById('achievement-alert');
        const SCRUB_DISTANCE_FACTOR = 0.8; // Portion of viewport needed to clean a calendar
        const TOP_BAR_HEIGHT = 42;
        let distancePerProgress = 600;
        let menuButtonBounds = { x: 0, y: 0, width: 0, height: 0 };
        let menuButtonHover = false;
        let allowResetButtonsReveal = false;
        let allowScrollIndicatorReveal = false;
        let resetButtonsShown = false;

        // Create a blurred dirt texture (offscreen)
        const dirtTextureSize = 64; // you can adjust
        const dirtTex = document.createElement('canvas');
        dirtTex.width = dirtTextureSize;
        dirtTex.height = dirtTextureSize;

        const dctx = dirtTex.getContext('2d');

        // very soft blur
        dctx.clearRect(0, 0, dirtTextureSize, dirtTextureSize);
        dctx.globalAlpha = 0.35;
        dctx.filter = 'blur(8px)';

        dctx.fillStyle = 'rgb(101, 67, 33)'; // your dirt brown
        dctx.beginPath();
        dctx.arc(
            dirtTextureSize / 2,
            dirtTextureSize / 2,
            dirtTextureSize * 0.35,
            0,
            Math.PI * 2
        );
        dctx.fill();

        // reset filter so the main canvas isn‚Äôt blurred
        dctx.filter = 'none';

        const DIRT_RENDER_SCALE = window.devicePixelRatio > 1.3 ? 0.6 : 0.75;

        function ensureDirtLayer(calendar, size) {
            if (!calendar.dirtCircles || size <= 0) return null;
            if (calendar.dirtCanvas && calendar.dirtCanvasSize === size) {
                return calendar.dirtCanvas;
            }

            const renderSize = Math.max(96, Math.round(size * DIRT_RENDER_SCALE));
            const layer = document.createElement("canvas");
            layer.width = renderSize;
            layer.height = renderSize;
            const layerCtx = layer.getContext("2d");

            const scale = renderSize / size;
            layerCtx.setTransform(scale, 0, 0, scale, 0, 0);
            layerCtx.clearRect(0, 0, size, size);

            for (const circle of calendar.dirtCircles) {
                const r = circle.rRatio * size;
                const cx = circle.cxRatio * size;
                const cy = circle.cyRatio * size;
                layerCtx.globalAlpha = circle.opacity;
                layerCtx.drawImage(dirtTex, cx - r, cy - r, r * 2, r * 2);
            }

            layerCtx.globalAlpha = 1;
            calendar.dirtCanvas = layer;
            calendar.dirtCanvasSize = size;
            return layer;
        }
 
        function roundedRectPath(ctx, x, y, w, h, r) {

            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function isPointInMenuButton(x, y) {
            const b = menuButtonBounds;
            return x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height;
        }
 
        function randomBetween(min, max) {

            return min + Math.random() * (max - min);
        }

        function getCalendarCenter(calendar) {
            return {
                x: calendar.x + calendar.size / 2,
                y: calendar.y + calendar.size / 2
            };
        }

        function getMonsterPairIndex(monthIndex) {
            if (Object.prototype.hasOwnProperty.call(MONSTER_SPAWN_PAIRS, monthIndex)) {
                return MONSTER_SPAWN_PAIRS[monthIndex];
            }
            return null;
        }

        function getFallbackSpawnPoint(calendar) {
            const center = getCalendarCenter(calendar);
            return {
                x: center.x,
                y: Math.max(40, center.y - calendar.size * 1.2)
            };
        }

        function getMonsterSpawnPoint(calendar, monthIndex) {
            const pairIndex = getMonsterPairIndex(monthIndex);
            if (pairIndex !== null) {
                const pairCalendar = calendars[pairIndex];
                if (pairCalendar) {
                    return getCalendarCenter(pairCalendar);
                }
            }
            return getFallbackSpawnPoint(calendar);
        }

        function createMonsterPath(calendar, monthIndex) {
            const center = getCalendarCenter(calendar);
            const spawnPoint = getMonsterSpawnPoint(calendar, monthIndex);
            const midX = (spawnPoint.x + center.x) / 2;
            const midY = (spawnPoint.y + center.y) / 2;
            const distance = Math.hypot(center.x - spawnPoint.x, center.y - spawnPoint.y);
            const offsetScale = Math.max(40, distance * 0.25);
            const angle = Math.atan2(center.y - spawnPoint.y, center.x - spawnPoint.x);
            const perpendicularAngle = angle + Math.PI / 2;
            const offset = offsetScale * (0.5 + Math.random() * 0.5);
            const offsetX = Math.cos(perpendicularAngle) * offset;
            const offsetY = Math.sin(perpendicularAngle) * offset;

            const c1 = {
                x: spawnPoint.x + offsetX * 0.4 + randomBetween(-60, 60),
                y: spawnPoint.y + offsetY * 0.4 + randomBetween(-60, 60)
            };
            const c2 = {
                x: midX + offsetX + randomBetween(-80, 80),
                y: midY + offsetY + randomBetween(-80, 80)
            };

            return {
                start: spawnPoint,
                c1,
                c2,
                end: center
            };
        }

        function getBezierPoint(t, path) {
            const u = 1 - t;
            const tt = t * t;
            const uu = u * u;
            const uuu = uu * u;
            const ttt = tt * t;

            const p = { x: 0, y: 0 };
            p.x = uuu * path.start.x;
            p.y = uuu * path.start.y;

            p.x += 3 * uu * t * path.c1.x;
            p.y += 3 * uu * t * path.c1.y;

            p.x += 3 * u * tt * path.c2.x;
            p.y += 3 * u * tt * path.c2.y;

            p.x += ttt * path.end.x;
            p.y += ttt * path.end.y;

            return p;
        }

        function getBezierTangent(t, path) {
            const u = 1 - t;
            const tt = t * t;
            const uu = u * u;

            const tangent = { x: 0, y: 0 };
            tangent.x = 3 * uu * (path.c1.x - path.start.x) +
                        6 * u * t * (path.c2.x - path.c1.x) +
                        3 * tt * (path.end.x - path.c2.x);
            tangent.y = 3 * uu * (path.c1.y - path.start.y) +
                        6 * u * t * (path.c2.y - path.c1.y) +
                        3 * tt * (path.end.y - path.c2.y);
            return tangent;
        }

        function monthsSinceMonsterIntro(monthIndex) {
            if (currentYear < MONSTER_START_YEAR) return 0;
            return Math.max(0, (currentYear - MONSTER_START_YEAR) * 12 + monthIndex);
        }

        function shouldMonsterBeActive() {
            return currentYear >= MONSTER_START_YEAR && currentActiveMonth < 12 && !gameOver && !monsterSuppressed;
        }

        function spawnMonsterForMonth(monthIndex) {
            if (!shouldMonsterBeActive()) return;
            const calendar = calendars[monthIndex];
            if (!calendar || calendar.isClean) return;

            const path = createMonsterPath(calendar, monthIndex);
            const monthsElapsed = monthsSinceMonsterIntro(monthIndex);
            const speed = MONSTER_BASE_SPEED + monthsElapsed * MONSTER_SPEED_INCREMENT;
            const requiresScrubStart = monsterDelayedAfterCatch || monthIndex === 0;

            const size = Math.max(30, calendar.size * MONSTER_SIZE_RATIO);
            monster = {
                targetMonth: monthIndex,
                path,
                progress: 0,
                speed,
                size,
                wobblePhase: Math.random() * Math.PI * 2,
                wobbleAmplitude: Math.max(12, calendar.size * 0.06),
                waitForScrub: requiresScrubStart,
                startedMoving: !requiresScrubStart,
                idleTime: 0,
                vanishing: false,
                vanishProgress: 0
            };
            monster.x = path.start.x;
            monster.y = path.start.y;
            if (monsterDelayedAfterCatch) {
                monsterDelayedAfterCatch = false;
            }
        }

        function ensureMonsterPresence() {
            if (!shouldMonsterBeActive()) {
                return;
            }
            if (!calendars[currentActiveMonth]) return;
            if (monster && monster.targetMonth === currentActiveMonth) return;
            spawnMonsterForMonth(currentActiveMonth);
        }

        function startMonsterVanish(reason) {
            if (!monster) return;
            const ghost = {
                ...monster,
                vanishing: true,
                vanishReason: reason,
                vanishProgress: 0
            };
            monsterGhosts.push(ghost);
            monster = null;
        }

        function suppressMonsterMovement() {
            monster = null;
            monsterGhosts = [];
            monsterSuppressed = true;
        }

        function updateMonsterGhosts() {
            if (monsterGhosts.length === 0) return;
            monsterGhosts = monsterGhosts.filter(ghost => {
                ghost.vanishProgress += frameDeltaSeconds / MONSTER_VANISH_DURATION;
                return ghost.vanishProgress < 1;
            });
        }

        function updateMonster() {
            if (!monster) return;
            const allowExisting = monster.targetMonth < currentActiveMonth;
            if (!shouldMonsterBeActive() && !allowExisting) {
                monster = null;
                return;
            }

            const calendar = calendars[monster.targetMonth];
            if (!calendar) return;

            if (calendar.isClean) {
                startMonsterVanish('defeated');
                return;
            }

            if (monster.waitForScrub && !monster.startedMoving) {
                monster.idleTime += frameDeltaSeconds;
                if (isCleaningInProgress) {
                    monster.startedMoving = true;
                    monster.waitForScrub = false;
                } else {
                    monster.x = monster.path.start.x + Math.sin(monster.idleTime * 2.5) * 8;
                    monster.y = monster.path.start.y + Math.cos(monster.idleTime * 2.5) * 4;
                    return;
                }
            }

            monster.progress += monster.speed * frameDeltaSeconds;
            if (monster.progress >= 1) {
                const end = monster.path.end;
                monster.x = end.x;
                monster.y = end.y;
                monster.progress = 1;
                handleMonsterReachedTarget();
                return;
            }

            const point = getBezierPoint(monster.progress, monster.path);
            const tangent = getBezierTangent(monster.progress, monster.path);
            const magnitude = Math.max(0.001, Math.hypot(tangent.x, tangent.y));
            const nx = -tangent.y / magnitude;
            const ny = tangent.x / magnitude;
            const wobble = Math.sin(monster.progress * Math.PI * 4 + monster.wobblePhase) * monster.wobbleAmplitude;

            monster.x = point.x + nx * wobble;
            monster.y = point.y + ny * wobble;
        }

        function handleMonsterReachedTarget() {
            if (!monster) return;
            const targetMonth = monster.targetMonth;
            const targetYear = currentYear;

            if (forcedHeritagePlan && forcedHeritagePlan.monthIndex === targetMonth && forcedHeritagePlan.year === targetYear) {
                startMonsterVanish('heritage-trigger');
                forcedHeritagePlan = null;
                triggerHeritageEvent('monster');
                return;
            }

            if (forcedHeritagePlan) {
                startMonsterVanish('waiting');
                return;
            }

            // If monster catches you in December of Year 2, trigger heritage instead of game over
            if (currentYear === 2 && targetMonth === 11) {
                startMonsterVanish('heritage-monster-december');
                triggerHeritageEvent('december-monster');
                return;
            }

            monsterCatchOccurred = true;
            startMonsterVanish('mahnung');
            completeMonthAfterCatch(targetMonth);
            if (gameOver) return;
            gameOver = true;
            isCleaningInProgress = false;
            sponge.isDragging = false;
            showGameOverPopup();
        }

        function showGameOverPopup() {
            if (gameOverOverlay) gameOverOverlay.classList.add('visible');
            if (gameOverPopup) gameOverPopup.classList.add('visible');
        }

        function hideGameOverPopup() {
            if (gameOverOverlay) gameOverOverlay.classList.remove('visible');
            if (gameOverPopup) gameOverPopup.classList.remove('visible');
        }

        function drawMonsterSprite(entity) {
            if (!entity) return;

            ctx.save();
            const size = entity.size;
            const alpha = entity.vanishing ? Math.max(0, 1 - entity.vanishProgress) : 1;
            const scale = entity.vanishing ? Math.max(0.25, 1 - entity.vanishProgress) : 1;

            ctx.translate(entity.x, entity.y);
            ctx.scale(scale, scale);
            ctx.globalAlpha = alpha;
            ctx.font = `${size * 1.8}px "Noto Color Emoji", "Apple Color Emoji", "Segoe UI Emoji", sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üßæ', 0, 0);
            ctx.restore();
        }

        function drawMonsters() {
            for (const ghost of monsterGhosts) {
                drawMonsterSprite(ghost);
            }
            if (monster) {
                drawMonsterSprite(monster);
            }
        }
 
        function resetCanvasToViewport() { 

            canvas.width = Math.min(800, window.innerWidth); 
            canvas.height = window.innerHeight; 
        }
        resetCanvasToViewport();

        function recalcDistancePerProgress() {
            const referenceSize = Math.min(window.innerWidth, window.innerHeight);
            distancePerProgress = Math.max(250, referenceSize * SCRUB_DISTANCE_FACTOR);
        }
        recalcDistancePerProgress();

        let animationComplete = false;
        let animationPaused = false;
        let manualMode = true; // Start in manual mode
        let greenPeaPlacementIndex = 0; // Track where to place next green peas
        
        // Calendar cleaning game state
        let spongeVisible = true;
        let sponge = { x: 0, y: 0, isDragging: false, offsetX: 0, offsetY: 0 };
        let calendars = []; // Will store calendar positions and states
        let currentActiveMonth = 0; // 0 = January, 1 = February, etc.
        let cleaningProgress = 0; // 0 to 1
        let isCleaningInProgress = false;
        let cleaningStartTime = 0;
        const CLEANING_DURATION = 1000; // 1 second per month
        const SHINE_SPEED = 2.8; // Progress per second for the shine sweep
        let yearlyPeasEarned = 0; // Track peas earned this year
        
        const MONSTER_START_YEAR = 2;
        const MONSTER_BASE_SPEED = 0.33;
        const MONSTER_SPEED_INCREMENT = 0.1;
        const MONSTER_VANISH_DURATION = 0.3;
        const MONSTER_SIZE_RATIO = 0.25;
        const MONSTER_SPAWN_PAIRS = {
            0: 2, 2: 0,
            1: 7, 7: 1,
            3: 5, 5: 3,
            4: 10, 10: 4,
            6: 8, 8: 6,
            9: 11, 11: 9
        };
        let monster = null;
        let monsterGhosts = [];
        let monsterSuppressed = false;
        let gameOver = false;
        let forcedHeritagePlan = null;
        let monsterCatchOccurred = false;
        let monsterDelayedAfterCatch = false;
        let spongeWiggleAfterCatch = false;
        let spongeWiggleStartTime = 0;
 
         
        // Scrubbing motion detection

        let lastSpongeX = 0;
        let lastSpongeY = 0;
        let scrubbingDistance = 0;
        const SCRUBBING_THRESHOLD = 1; // Minimum pixels to move to count as scrubbing
        
        // Tutorial state
        let tutorialShown = false;
        let showTutorial = false;
        let tutorialStartTime = performance.now();
        let tutorialTimeout = null;
        const TUTORIAL_DELAY = 50; // 50 milliseconds
        let tutorialPhase = 1; // 1 = first tutorial, 2 = second tutorial

        function getTutorialText() {
            if (tutorialPhase === 2) {
                return "Die Krankenkassenpr√§mien sind um 20% gestiegen. Schaffst du es durch das 2. Jahr, bevor dich der Pr√§mienschock einholt?";
            }
            return "<p>Schrubbe mit dem Schwamm √ºber die schmutzigen Kalender, um sie zu reinigen!</p>  <p>F√ºr jeden sauberen Monat wird dir dein Monatsgehalt ausgezahlt.</p>";
        }

        function getTutorialIcon() {
            return tutorialPhase === 2 ? 'üßæ' : 'üßΩ';
        }

        function updateTutorialOverlayText() {
            if (!tutorialText) return;
            tutorialText.innerHTML = `<p>${getTutorialText()}</p>`;
        }

        function updateTutorialOverlayIcon() {
            if (!tutorialIcon) return;
            tutorialIcon.textContent = getTutorialIcon();
        }

        function syncTutorialOverlay() {
            if (!tutorialOverlay) return;
            updateTutorialOverlayText();
            updateTutorialOverlayIcon();
            tutorialOverlay.classList.toggle('visible', showTutorial);
            tutorialOverlay.setAttribute('aria-hidden', String(!showTutorial));
        }

        syncTutorialOverlay();
        
        // Tax popup state
        let taxPopupStep = 0; // 0 = not shown, 1 = first message, 2 = second message
        
        // Heritage event state
        let heritageEventTriggered = false;
        let postCascadeTaxDelay = 1000; // Delay after cascade completes before showing tax popup (in ms)

        const PEA_SIZE = 12;
        const PEA_RADIUS = PEA_SIZE / 2;
        const TOTAL_PEAS = 50000;
        const SPAWN_RATE = 675;
        const FALL_SPEED = 67.5;
        const RED_BLINK_TIME = 1000;

        const GRID_CELL_SIZE = PEA_SIZE;

        function calcGridCols() { return Math.max(1, Math.floor(canvas.width / GRID_CELL_SIZE)); }
        function calcGridRows() { return Math.max(1, Math.floor(canvas.height / GRID_CELL_SIZE)); }
        let gridCols = calcGridCols();
        let gridRows = calcGridRows();

        let columnsToSpawn = [];
        let currentBatchIndex = 0;
        const occupiedGrid = new Set();
        const lastSpawnTime = new Map();

        function isScreenFull() {
            let requiredRows = [-1, -2, -3, -4];
            for (const r of requiredRows) {
                for (let col = 0; col < gridCols; col++) {
                    if (!occupiedGrid.has(getGridKey(col, r))) return false;
                }
            }
            return true;
        }

        function generateCompleteStack() {
            console.log("Generating complete stack...");

            // Recompute grid dims
            gridCols = calcGridCols();
            gridRows = calcGridRows();

            // Compute total rows needed for TOTAL_PEAS
            const totalRows = Math.ceil(TOTAL_PEAS / gridCols);
            const totalHeight = totalRows * GRID_CELL_SIZE;

            // Number of rows to insert ABOVE the current viewport so Part A (visible area) stays in place
            const extraRowsAbove = Math.max(0, totalRows - gridRows);

            // Snapshot visible region
            const visibleHeight = window.innerHeight;
            const visibleWidth = canvas.width;
            const visibleSnapshot = ctx.getImageData(0, 0, visibleWidth, visibleHeight);

            // Collect peas inside visible region (Part A)
            const preservedVisible = [];
            function addPreserved(pea, colorIndex, isGreen) {
                const oldRow = Math.floor((pea.y + 0.5) / GRID_CELL_SIZE);
                preservedVisible.push({ x: pea.x, y: pea.y, col: pea.col, oldRow, colorIndex, isGreen });
            }

            const settledSnapshot = settledPeas.slice();
            const activeSnapshot = peas.slice();

            for (let i = 0; i < settledSnapshot.length; i++) {
                const pea = settledSnapshot[i];
                const peaY = pea.y;
                if (peaY >= 0 && peaY < visibleHeight) {
                    const derivedColor = pea.colorIndex !== undefined ? pea.colorIndex : (i % peaColors.length);
                    addPreserved(pea, derivedColor, pea.isGreen);
                }
            }
            for (let i = 0; i < activeSnapshot.length; i++) {
                const pea = activeSnapshot[i];
                const peaY = pea.y;
                if (peaY >= 0 && peaY < visibleHeight) {
                    const derivedColor = pea.colorIndex !== undefined ? pea.colorIndex : (i % peaColors.length);
                    addPreserved(pea, derivedColor, false);
                }
            }


            // Rebuild world state
            peas = [];
            settledPeas = [];
            occupiedGrid.clear();

            const locked = new Set();

            // Restore preserved Part A peas at shifted rows
            for (const p of preservedVisible) {
                const newRow = p.oldRow + extraRowsAbove;
                const newY = newRow * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;

                const pea = {
                    x: p.x,
                    y: newY,
                    col: p.col,
                    row: newRow,
                    colorIndex: p.colorIndex,
                    settled: true,
                    isGreen: p.isGreen || false
                };
                settledPeas.push(pea);
                occupyGrid(p.col, newRow);
                locked.add(getGridKey(p.col, newRow));
            }

            // PART B: generate flipped full rows above Part A (golden peas only)
            // We always fill ALL columns of ALL rows above, so no incomplete rows exist.
            for (let row = 0; row < extraRowsAbove; row++) {
                const flippedRow = extraRowsAbove - 1 - row; // flip order
                for (let col = 0; col < gridCols; col++) {
                    const key = getGridKey(col, flippedRow);
                    if (!locked.has(key)) {
                        const pea = {
                            x: col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                            y: flippedRow * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                            col,
                            row: flippedRow,
                            colorIndex: Math.floor(Math.random() * peaColors.length),
                            settled: true,
                            isGreen: false
                        };
                        settledPeas.push(pea);
                        occupyGrid(col, flippedRow);
                    }
                }
            }

            // Fill all remaining rows below Part B (golden peas only)
            for (let row = extraRowsAbove; row < totalRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const key = getGridKey(col, row);
                    if (!locked.has(key)) {
                        const pea = {
                            x: col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                            y: row * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                            col,
                            row,
                            colorIndex: Math.floor(Math.random() * peaColors.length),
                            settled: true,
                            isGreen: false
                        };
                        settledPeas.push(pea);
                        occupyGrid(col, row);
                    }
                }
            }

            // Resize and enable scrolling
            canvas.height = totalHeight;
            gridRows = totalRows;
            document.body.style.overflow = 'scroll';
            animationComplete = true;

            // Fill the expanded area with grey background
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw the complete stack (golden peas only in the new top area)
            draw();
            
            // Paste the preserved visible snapshot at the bottom (includes calendars, top bar, green peas, etc.)
            const pasteY = totalHeight - visibleHeight;
            ctx.putImageData(visibleSnapshot, 0, pasteY);

            const targetScrollY = document.documentElement.scrollHeight - window.innerHeight;
            window.scrollTo(0, targetScrollY);

            setTimeout(() => {
                scrollIndicator.textContent = 'Nach oben scrollen um deinen ganzen Reichtum zu entdecken';
                updateScrollIndicator();
            }, 100);
        }

        function initializeSpawnOrder() {
            columnsToSpawn = [];
            for (let i = 0; i < TOTAL_PEAS; i++) columnsToSpawn.push(i % gridCols);
            for (let i = columnsToSpawn.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [columnsToSpawn[i], columnsToSpawn[j]] = [columnsToSpawn[j], columnsToSpawn[i]];
            }
        }
        initializeSpawnOrder();

        function getGridKey(col, row) { return `${col},${row}`; }
        function isGridOccupied(col, row) { if (row >= gridRows) return true; if (col < 0 || col >= gridCols) return true; return occupiedGrid.has(getGridKey(col, row)); }
        function occupyGrid(col, row) { occupiedGrid.add(getGridKey(col, row)); }

        function activateGreenPea(greenPea) {
            // Find all green peas in this column and neighboring columns at or below this row
            const columnsToCheck = [greenPea.col - 1, greenPea.col, greenPea.col + 1];
            
            const greenPeasToActivate = settledPeas.filter(p => 
                p.isGreen && columnsToCheck.includes(p.col) && p.row >= greenPea.row
            );
            
            // Sort by row (top to bottom) to activate in order
            greenPeasToActivate.sort((a, b) => a.row - b.row);
            
            // Activate all of them
            for (const pea of greenPeasToActivate) {
                // Remove from settled peas
                const index = settledPeas.indexOf(pea);
                if (index > -1) {
                    settledPeas.splice(index, 1);
                }
                
                // Clear its grid position
                occupiedGrid.delete(getGridKey(pea.col, pea.row));
                
                // Mark as active and falling
                pea.settled = false;
                pea.isFalling = true;
                
                // Add methods to make it behave like a Pea instance
                pea.update = Pea.prototype.update;
                pea.settleInGrid = Pea.prototype.settleInGrid;
                
                // Add to active peas array
                peas.push(pea);
            }
        }

        class Pea {
            constructor(col) { 
                this.col = col; 
                this.x = col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2; 
                this.y = -PEA_RADIUS - Math.random() * 600; 
                this.settled = false;
                this.isGreen = false;
                this.isFalling = false;
            }
            update() {
                if (this.settled) return;
                this.y += FALL_SPEED;
                const currentRow = Math.floor(this.y / GRID_CELL_SIZE);
                
                // Check if at bottom edge
                if (currentRow >= gridRows - 1) {
                    this.settleInGrid(this.col, gridRows - 1);
                    return;
                }
                
                // For golden peas, activate any green peas they pass through
                if (!this.isGreen) {
                    const greenPeaInCurrentRow = settledPeas.find(p => 
                        p.isGreen && p.col === this.col && p.row === currentRow
                    );
                    if (greenPeaInCurrentRow) {
                        activateGreenPea(greenPeaInCurrentRow);
                    }
                }
                
                // Check what's in the next row (only settle if it's a non-green occupied space)
                const nextRow = currentRow + 1;
                const nextRowHasNonGreenPea = settledPeas.find(p => 
                    !p.isGreen && p.col === this.col && p.row === nextRow
                );
                
                // Only settle if hitting a golden pea or at the edge
                if (nextRowHasNonGreenPea) {
                    this.settleInGrid(this.col, currentRow);
                }
            }
            settleInGrid(col, row) {
                // Find first available spot
                if (isGridOccupied(col, row)) {
                    for (let r = row; r >= -4; r--) { 
                        if (!isGridOccupied(col, r)) { 
                            row = r; 
                            break; 
                        } 
                    }
                }
                this.x = col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                this.y = row * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                this.row = row;
                this.settled = true;
                this.isFalling = false;
                occupyGrid(col, row);
            }
        }

        let peas = [];
        let settledPeas = [];
        let spawnedCount = 0;
        let frameCount = 0;
        let currentYear = 1;
        let currentMoney = 0;
        let erbsenNotification = null; // { text, opacity, offsetY, startTime }
        const peaColors = ['#FFEB3B', '#FFD54F', '#FFCA28', '#FFC107', '#FFB300'];
        const greenPeaColors = ['#7CB342', '#8BC34A', '#9CCC65', '#AED581', '#689F38'];

        // Calculate green pea spawn area (peas start 10 rows from bottom, background goes to edge)
        function getGreenPeaArea() {
            const startRow = gridRows - 10; // Start 10 rows from bottom
            const endRow = gridRows; // Background goes to bottom edge
            return { 
                startRow, 
                endRow,
                bgStartRow: startRow - 1 // Background starts 1 row above for padding
            };
        }

        function initializeGreenPeas() {
            // Place 3 rows of green peas in lower third of screen, excluding border columns
            const lowerThirdStartRow = Math.floor(gridRows * 2 / 3);
            const startRow = lowerThirdStartRow;
            const endRow = startRow + 3;
            
            // Exclude ~10% of columns from each side
            const marginCols = Math.floor(gridCols * 0.1);
            const startCol = marginCols;
            const endCol = gridCols - marginCols;
            
            for (let row = startRow; row < endRow && row < gridRows; row++) {
                for (let col = startCol; col < endCol; col++) {
                    const pea = {
                        x: col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                        y: row * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                        col: col,
                        row: row,
                        colorIndex: Math.floor(Math.random() * greenPeaColors.length),
                        settled: true,
                        isGreen: true
                    };
                    settledPeas.push(pea);
                    occupyGrid(col, row);
                }
            }
        }
        
        function addFourGreenPeas() {
            // Calculate green pea area (with 5 rows spacing at bottom)
            const greenArea = getGreenPeaArea();
            const lowerQuarterStartRow = greenArea.startRow;
            const maxRow = greenArea.endRow;
            
            // Add padding of 2 peas on each side
            const marginCols = 2;
            const startCol = marginCols;
            const endCol = gridCols - marginCols;
            const availableCols = endCol - startCol;
            
            // Add 4 green peas with staggered timing
            for (let i = 0; i < 4; i++) {
                const currentIndex = greenPeaPlacementIndex + i;
                setTimeout(() => {
                    const colOffset = currentIndex % availableCols;
                    const col = startCol + colOffset;
                    const row = lowerQuarterStartRow + Math.floor(currentIndex / availableCols);
                    
                    if (row >= maxRow) {
                        alert('Green pea area is full!');
                        return;
                    }
                    
                    // Check if already occupied
                    if (!isGridOccupied(col, row)) {
                        const pea = {
                            x: col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                            y: row * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                            col: col,
                            row: row,
                            colorIndex: Math.floor(Math.random() * greenPeaColors.length),
                            settled: true,
                            isGreen: true,
                            isPulsating: true,
                            pulseTime: 0,
                            pulseDuration: 6,
                            baseRadius: PEA_RADIUS
                        };
                        settledPeas.push(pea);
                        occupyGrid(col, row);
                        
                        // Add money (1000 per green pea)
                        currentMoney += 1000;
                        
                        // Animate pulsation
                        const pulseInterval = setInterval(() => {
                            pea.pulseTime++;
                            if (pea.pulseTime >= pea.pulseDuration) {
                                pea.isPulsating = false;
                                clearInterval(pulseInterval);
                            }
                            draw();
                        }, 16);
                    }
                }, i * 25);
            }
            
            greenPeaPlacementIndex += 4;
            
            // Trigger "+4 Erbsen" notification animation
            erbsenNotification = {
                text: '+4 Erbsen',
                opacity: 1.0,
                offsetY: 0,
                startTime: performance.now(),
                isNegative: false
            };
        }
        
        function removeFiveGreenPeas() {
            // Find first 5 green peas (from top-left)
            const greenPeas = settledPeas.filter(p => p.isGreen);
            if (greenPeas.length === 0) {
                alert('No green peas to remove!');
                return;
            }
            
            // Sort by row then column (top-left first)
            greenPeas.sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row;
                return a.col - b.col;
            });
            
            const peasToRemove = greenPeas.slice(0, Math.min(5, greenPeas.length));
            const actualRemoveCount = peasToRemove.length;
            
            // Mark peas for blinking
            peasToRemove.forEach(pea => {
                pea.isBlinking = true;
                pea.blinkStartTime = performance.now();
            });
            
            // Trigger "-5 Erbsen" notification when blinking starts
            erbsenNotification = {
                text: `-${actualRemoveCount} Erbsen`,
                opacity: 1.0,
                offsetY: 0,
                startTime: performance.now(),
                isNegative: true
            };
            
            // After blinking, remove peas and reposition
            setTimeout(() => {
                // Remove the peas
                peasToRemove.forEach(pea => {
                    const index = settledPeas.indexOf(pea);
                    if (index > -1) {
                        settledPeas.splice(index, 1);
                        occupiedGrid.delete(getGridKey(pea.col, pea.row));
                    }
                });
                
                // Subtract money
                currentMoney -= actualRemoveCount * 1000;
                
                // Reposition remaining green peas to fill gaps
                repositionGreenPeas();
                
                // Update placement index to reflect actual number of green peas
                const remainingGreenPeas = settledPeas.filter(p => p.isGreen).length;
                greenPeaPlacementIndex = remainingGreenPeas;
            }, RED_BLINK_TIME); // Blink for 500ms
        }
        
        function repositionGreenPeas() {
            const greenArea = getGreenPeaArea();
            const lowerQuarterStartRow = greenArea.startRow;
            const marginCols = 2;
            const startCol = marginCols;
            const endCol = gridCols - marginCols;
            const availableCols = endCol - startCol;
            
            // Get all green peas
            const greenPeas = settledPeas.filter(p => p.isGreen);
            
            // Clear their old positions
            greenPeas.forEach(pea => {
                occupiedGrid.delete(getGridKey(pea.col, pea.row));
            });
            
            // Sort by current position (to maintain relative order)
            greenPeas.sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row;
                return a.col - b.col;
            });
            
            // Reposition them sequentially from top-left
            greenPeas.forEach((pea, index) => {
                const colOffset = index % availableCols;
                const col = startCol + colOffset;
                const row = lowerQuarterStartRow + Math.floor(index / availableCols);
                
                // Animate smooth transition
                pea.targetX = col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                pea.targetY = row * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                pea.isMoving = true;
                pea.moveStartTime = performance.now();
                pea.startX = pea.x;
                pea.startY = pea.y;
                pea.targetCol = col;
                pea.targetRow = row;
            });
        }
        
        // Don't auto-initialize in manual mode

        function spawnPeas() {
            const rate = Math.min(SPAWN_RATE, TOTAL_PEAS - spawnedCount);
            const MIN_SPAWN_GAP = 1;
            let spawned = 0; let attempts = 0; const maxAttempts = rate * 3;
            while (spawned < rate && spawnedCount < TOTAL_PEAS && attempts < maxAttempts) {
                attempts++;
                const col = columnsToSpawn[currentBatchIndex % columnsToSpawn.length];
                const lastSpawn = lastSpawnTime.get(col) || -Infinity;
                if (frameCount - lastSpawn >= MIN_SPAWN_GAP) { peas.push(new Pea(col)); lastSpawnTime.set(col, frameCount); spawnedCount++; spawned++; }
                currentBatchIndex++;
            }
        }

        function update() {
            // Handle calendar cleaning progress (needs to work even when paused)
            if (isCleaningInProgress && currentActiveMonth < 12) {
                // Update the active calendar's progress based on its scrubbing distance
                const calendar = calendars[currentActiveMonth];
                calendar.progress = Math.min(calendar.scrubbingDistance / distancePerProgress, 1);
                
                if (calendar.progress >= 1) {
                    // Cleaning complete!
                    calendar.isClean = true;
                    calendar.isDirty = false;
                    isCleaningInProgress = false;
                    calendar.shineActive = true;
                    calendar.shineProgress = 0;
                    calendar.pop = 1.0;

                    if (monster && monster.targetMonth === currentActiveMonth) {
                        startMonsterVanish('defeated');
                    }
                    
                    // Add 4 green peas
                    addFourGreenPeas();
                    
                    // Track yearly income
                    yearlyPeasEarned += 4;
                    
                    const justCleanedMonth = currentActiveMonth;
                    const justCleanedYear = currentYear;

                    // Move to next month
                    currentActiveMonth++;

                    if (maybeTriggerForcedHeritageAfterCleaning(justCleanedMonth, justCleanedYear)) {
                        return;
                    }

                    if (maybeTriggerGuaranteedHeritage(justCleanedMonth, justCleanedYear)) {
                        return;
                    }
                    
                    // Check if all 12 calendars are cleaned (regular tax event)
                    if (currentActiveMonth >= 12) {
                        if (currentYear === 1) {
                            setTimeout(() => {
                                showTaxPopup();
                            }, 500);
                        } else if (!heritageEventTriggered) {
                            triggerHeritageEvent('year-two-complete');
                        }
                    }
                }
            }
            
            updateMonsterGhosts();
            if (gameOver) return;

            updateMonster();
            if (gameOver) return;

            if (animationComplete || animationPaused) return;
            
            if (!manualMode && isScreenFull()) { animationPaused = true; console.log("Required above-screen rows filled √¢‚Ç¨‚Äù transitioning to complete stack..."); requestAnimationFrame(() => { generateCompleteStack(); }); return; }
            frameCount++;
            if (!manualMode && spawnedCount < TOTAL_PEAS) spawnPeas();
            const stillActive = [];
            for (let i = 0; i < peas.length; i++) { const pea = peas[i]; pea.update(); if (pea.settled) settledPeas.push(pea); else stillActive.push(pea); }
            peas = stillActive;
        }

        function drawCalendars(startY, endY) {
            const monthNames = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni', 
                                'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
            
            const availableHeight = endY - startY;
            const availableWidth = canvas.width;
            const padding = 15;
            
            // Calculate optimal grid layout (rows x cols)
            let bestLayout = { rows: 3, cols: 4 }; // Default: 3 rows, 4 cols
            
            // Try different layouts to find the best fit
            const layouts = [
                { rows: 2, cols: 6 },
                { rows: 3, cols: 4 },
                { rows: 4, cols: 3 },
                { rows: 6, cols: 2 }
            ];
            
            let maxCalendarSize = 0;
            for (const layout of layouts) {
                const calWidth = (availableWidth - padding * (layout.cols + 1)) / layout.cols;
                const calHeight = (availableHeight - padding * (layout.rows + 1)) / layout.rows;
                const calSize = Math.min(calWidth, calHeight);
                
                if (calSize > maxCalendarSize) {
                    maxCalendarSize = calSize;
                    bestLayout = layout;
                }
            }
            
            const { rows, cols } = bestLayout;
            const calWidth = (availableWidth - padding * (cols + 1)) / cols;
            const calHeight = (availableHeight - padding * (rows + 1)) / rows;
            const calSize = Math.min(calWidth, calHeight);
            
            // Calculate total grid dimensions
            const totalGridWidth = cols * calSize + (cols - 1) * padding;
            const totalGridHeight = rows * calSize + (rows - 1) * padding;
            
            // Center the entire grid vertically and horizontally
            const gridOffsetX = (availableWidth - totalGridWidth) / 2;
            const gridOffsetY = (availableHeight - totalGridHeight) / 2;
            
            // Draw each calendar
            for (let i = 0; i < 12; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                
                const x = gridOffsetX + col * (calSize + padding);
                const y = startY + gridOffsetY + row * (calSize + padding);
                
                drawCalendar(x, y, calSize, monthNames[i], i);
            }
        }
        
        function drawCalendar(x, y, size, monthName, monthIndex) {
            // Store calendar position for collision detection
            if (!calendars[monthIndex]) {
                calendars[monthIndex] = {
                    x, y, size, monthName, monthIndex,
                    isClean: false,
                    isDirty: true,
                    progress: 0, // Individual progress for this calendar
                    scrubbingDistance: 0, // Individual scrubbing distance for this calendar
                    shineActive: false,
                    shineProgress: 0,
                    dirtCircles: null,
                    dirtCanvas: null,
                    dirtCanvasSize: 0,
                    pop: 0,
                };
            } else {
                calendars[monthIndex].x = x;
                calendars[monthIndex].y = y;
                calendars[monthIndex].size = size;
            }
            
            const calendar = calendars[monthIndex];

            // Generate dirt spots once (store normalized coordinates so we can rebuild fast)
            if (!calendar.dirtCircles) {
                calendar.dirtCircles = [];

                const circleCount = Math.max(48, Math.round(40 + size * 0.045));
                const minRatio = 0.02;
                const maxRatio = 0.16;

                for (let i = 0; i < circleCount; i++) {
                    const rRatio = minRatio + Math.random() * (maxRatio - minRatio);
                    const cxRatio = rRatio + Math.random() * (1 - 2 * rRatio);
                    const cyRatio = rRatio + Math.random() * (1 - 2 * rRatio);
                    const opacity = 0.25 + Math.random() * 0.55;

                    calendar.dirtCircles.push({ cxRatio, cyRatio, rRatio, opacity });
                }
            }



            
            // Days in each month (non-leap year)
            const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            const maxDays = daysInMonth[monthIndex];
            

            ctx.save(); // Save state before clipping

            // POP ANIMATION ‚Äî scale up and down
            if (calendar.pop > 0) {
                const p = calendar.pop; 

                // Ease curve (0‚Üí1‚Üí0)
                const scale = 1 + Math.sin(p * Math.PI) * 0.06;  
                // 0.18 = 18% bigger at the peak

                const cx = x + size / 2;
                const cy = y + size / 2;

                ctx.translate(cx, cy);
                ctx.scale(scale, scale);
                ctx.translate(-cx, -cy);

                // decrease pop over time
                calendar.pop -= 0.015;   // tweak for slower/faster pop
                if (calendar.pop < 0) calendar.pop = 0;
            }


            roundedRectPath(ctx, x, y, size, size, size * 0.05);  
            ctx.clip(); // Clip everything visually to rounded corners



            // Calendar background
            if (calendar.isClean) {
                // Completed: dark grey background
                const g = ctx.createLinearGradient(x, y, x, y + size);
                g.addColorStop(0, "#6a6a6a");
                g.addColorStop(1, "#3c3c3c");
                ctx.fillStyle = g;
                ctx.fillRect(x, y, size, size);
            } else if(monthIndex > currentActiveMonth && !calendar.isClean) {
                ctx.fillStyle = '#7E5600';
            }
                        
            else {
                // Not completed: white/light background
                ctx.fillStyle = '#f5f5f5';
            }
            ctx.fillRect(x, y, size, size);
            

            
            // Calendar header
            const headerHeight = size * 0.25;
            if (calendar.isClean) {
                // Completed: even darker grey header for better contrast
                ctx.fillStyle = '#1a1a1a';
            } else  if (monthIndex > currentActiveMonth && !calendar.isClean){
                // Not completed: red header
                ctx.fillStyle = '#120C00';
            } else {
                ctx.fillStyle = '#d32f2f';
            }

            ctx.fillRect(x, y, size, headerHeight);
            
            // Month name on header
            if (calendar.isClean) {
                // Completed: darker grey text
                ctx.fillStyle = '#757575';
            } else  if (monthIndex > currentActiveMonth && !calendar.isClean){
                // Not completed: red header
                ctx.fillStyle = '#ffffff';
            } else {
                ctx.fillStyle = '#ffffff';
            }
            ctx.font = `bold ${Math.max(11, size * 0.14)}px Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(monthName, x + size / 2, y + headerHeight / 2);
            
            
            // Calendar body (only show day numbers if not completed)
            if (!calendar.isClean) {
                const gridStartY = y + headerHeight + size * 0.08;
                const gridWidth = size * 0.85;
                const gridHeight = size * 0.6;
                const gridStartX = x + (size - gridWidth) / 2;
                const cellWidth = gridWidth / 7;
                const cellHeight = gridHeight / 5;
                
                ctx.font = `${Math.max(8, size * 0.09)}px Arial, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw day numbers (only up to maxDays for this month)
                let dayNum = 1;
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 7; col++) {
                        if (dayNum <= maxDays) {
                            const cellX = gridStartX + col * cellWidth;
                            const cellY = gridStartY + row * cellHeight;
                            
                            // Alternate slight grey for some visual interest
                            if ((row + col) % 2 === 0) {
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
                                ctx.fillRect(cellX, cellY, cellWidth, cellHeight);
                            }
                            
                            // Day number
                            ctx.fillStyle = '#4a4a4a';
                            ctx.fillText(dayNum.toString(), cellX + cellWidth / 2, cellY + cellHeight / 2);
                            dayNum++;
                        }
                    }
                }
            }


    
            // Draw dirt overlay if dirty (with progressive opacity reduction during cleaning)
            if (calendar.isDirty && !calendar.isClean) {
                // Calculate dirt opacity based on cleaning progress (use calendar's stored progress)
                let dirtOpacity = 1.0;
                if (monthIndex === currentActiveMonth) {
                    dirtOpacity = 1.0 - calendar.progress; // Use individual calendar progress
                }
                
                ctx.fillStyle = `rgba(139, 90, 43, ${0.8 * dirtOpacity})`; // Brown semi-transparent dirt
                ctx.fillRect(x, y, size, size);
                
                const dirtLayer = ensureDirtLayer(calendar, size);
                if (dirtLayer) {
                    ctx.save();
                    ctx.globalAlpha = dirtOpacity;
                    ctx.drawImage(dirtLayer, x, y, size, size);
                    ctx.restore();
                }
            }





            // Darken if not the current active month and not yet clean
            if (monthIndex > currentActiveMonth && !calendar.isClean) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(x, y, size, size);
            }
            // Draw green checkmark if completed (centered in lower part)
            if (calendar.isClean) {
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = Math.max(4, size * 0.03);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Center in the lower part (below the header)
                const lowerPartStartY = y + headerHeight;
                const lowerPartHeight = size - headerHeight;
                const lowerPartCenterY = lowerPartStartY + lowerPartHeight / 2;
                
                const checkSize = size * 0.3;
                const checkX = x + size / 2 - checkSize / 3;
                const checkY = lowerPartCenterY;
                
                ctx.beginPath();
                ctx.moveTo(checkX, checkY);
                ctx.lineTo(checkX + checkSize / 3, checkY + checkSize / 3);
                ctx.lineTo(checkX + checkSize, checkY - checkSize / 2);
                ctx.stroke();
            }
            


            // Draw progress bar if currently being cleaned OR has partial progress
            if (monthIndex === currentActiveMonth && calendar.progress > 0 && !calendar.isClean) {
                const barHeight = size * 0.06;
                const barY = y + size - barHeight - size * 0.05;
                const barX = x + size * 0.1;
                const barWidth = size * 0.8;
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Progress (use calendar's stored progress)
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(barX, barY, barWidth * calendar.progress, barHeight);
                
                // Border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }

            // Rounded green outline for completed calendar
            if (calendar.isClean) {
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = Math.max(4, size * 0.03);

                // Recreate the same rounded path used for clipping
                roundedRectPath(ctx, x, y, size, size, size * 0.05);
                ctx.stroke();
            }

            


            drawCalendarShine(calendar);
            ctx.restore();
        }



        function drawCalendarShine(calendar) {
            if (!calendar.shineActive) return;

            const { x, y, size } = calendar;

            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, size, size);
            ctx.clip();

            const stripeWidth = size * 0.2;
            const px = x + calendar.shineProgress * (size + stripeWidth) - stripeWidth;

            const grad = ctx.createLinearGradient(
                px - stripeWidth, y,
                px + stripeWidth, y + size
            );

            grad.addColorStop(0, "rgba(255,255,255,0)");
            grad.addColorStop(0.5, "rgba(255,255,255,0.55)");
            grad.addColorStop(1, "rgba(255,255,255,0)");



            ctx.fillStyle = grad;
            ctx.fillRect(x, y, size, size);

            calendar.shineProgress += SHINE_SPEED * frameDeltaSeconds;

            if (calendar.shineProgress >= 1.5) {
                calendar.shineActive = false;
            }

            ctx.restore();
        }


        function draw() {
            ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw top bar background
            ctx.fillStyle = 'rgba(30, 30, 30, 0.7)';
            ctx.fillRect(0, 0, canvas.width, TOP_BAR_HEIGHT);
            
            // Draw top bar text
            ctx.font = 'bold 18px Arial, sans-serif';
            ctx.textBaseline = 'middle';
            
            // Menu icon (left)
            const iconFontSize = 26;
            const iconPadding = 14;
            const iconCenterY = TOP_BAR_HEIGHT / 2;
            const iconX = 20;
            const boundsSize = iconFontSize + iconPadding;
            menuButtonBounds = {
                x: iconX - iconPadding * 0.4,
                y: iconCenterY - boundsSize / 2,
                width: boundsSize,
                height: boundsSize
            };
            ctx.save();
            ctx.fillStyle = menuButtonHover ? '#A7E059' : '#7CB342';
            ctx.font = `bold ${iconFontSize}px Arial, sans-serif`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText('<', iconX, iconCenterY);
            ctx.restore();
            
            // Year display (center)
            ctx.font = 'bold 18px Arial, sans-serif';
            ctx.fillStyle = '#7CB342';
            ctx.textAlign = 'center';
            ctx.fillText('Jahr ' + currentYear, canvas.width / 2, TOP_BAR_HEIGHT / 2);
            
            // Draw calendars between top bar and Erbsen-Bank
            const greenArea = getGreenPeaArea();
            const bgStartY = greenArea.bgStartRow * GRID_CELL_SIZE;
            drawCalendars(TOP_BAR_HEIGHT, bgStartY - 20); // Start after top bar, end before Erbsen-Bank
            ensureMonsterPresence();
            drawMonsters();
            
            // Initialize sponge position on first draw if calendars exist
            if (calendars.length > 0 && sponge.x === 0 && sponge.y === 0) {
                const januaryCalendar = calendars[0];
                if (januaryCalendar) {
                    sponge.x = januaryCalendar.x + januaryCalendar.size / 2;
                    sponge.y = januaryCalendar.y + januaryCalendar.size / 2; // On top of January (center)
                }
            }
            
            // Draw greenish background for green pea area (with padding above)
            const bgEndY = greenArea.endRow * GRID_CELL_SIZE;
            const bgHeight = bgEndY - bgStartY;
            ctx.fillStyle = 'rgba(124, 179, 66, 0.15)'; // Semi-transparent green
            ctx.fillRect(0, bgStartY, canvas.width, bgHeight);
            
            // Draw "Erbsen-Bank" label
            const marginCols = 2;
            const labelX = canvas.width - (marginCols * GRID_CELL_SIZE);
            const labelY = bgStartY - 5; // 5px above the background
            ctx.fillStyle = '#7CB342'; // Green color
            ctx.font = '18px Arial, sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            ctx.fillText('Erbsen-Bank', labelX, labelY);

            // Draw green pea value indicator ("pea = 1'000")
            (function drawPeaValueIndicator() {
            const peaX = canvas.width - 90;   // horizontal position
            const peaY = canvas.height - 20;;        // just below Erbsen-Bank

            // Draw real-money counter in Erbsen-Bank (bottom-left)
            (function drawMoneyCounter() {

                const moneyX = marginCols * GRID_CELL_SIZE;     // left side of the green-pea area
                const moneyY = canvas.height - 20;              // same vertical position as the pea value text

                // Draw CHF money text like the pea-value text
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial, sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';

                ctx.fillText(
                    currentMoney.toLocaleString('de-CH') + ".-", 
                    moneyX, 
                    moneyY
                );
            })();


            // Draw pea (same as green peas in game)
            ctx.fillStyle = greenPeaColors[0];
            ctx.beginPath();
            ctx.arc(peaX, peaY, PEA_RADIUS, 0, Math.PI * 2);
            ctx.fill();

            // Draw text
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial, sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText("= 1'000.-", peaX + PEA_RADIUS + 8, peaY);
            })();

            
            // Draw "+4 Erbsen" notification animation
            if (erbsenNotification) {
                const elapsed = performance.now() - erbsenNotification.startTime;
                const duration = 1000; // 1 second 
                
                if (elapsed < duration) {
                    // Animate upward and fade out
                    const progress = elapsed / duration;
                    erbsenNotification.offsetY = progress * 40; // Move up 40px
                    erbsenNotification.opacity = 1 - progress; // Fade out
                    
                    ctx.save();
                    // Green for positive, red for negative
                    const color = erbsenNotification.isNegative ? '211, 47, 47' : '124, 179, 66';
                    ctx.fillStyle = `rgba(${color}, ${erbsenNotification.opacity})`;
                    ctx.font = 'bold 20px Arial, sans-serif';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'bottom';
                    const notificationX = marginCols * GRID_CELL_SIZE;
                    ctx.fillText(erbsenNotification.text, notificationX, labelY + 0 - erbsenNotification.offsetY); // Start lower (was labelY - 10)
                    ctx.restore();
                } else {
                    // Animation complete
                    erbsenNotification = null;
                }
            }
            
            // Draw settled green peas
            for (let colorIdx = 0; colorIdx < greenPeaColors.length; colorIdx++) {
                ctx.fillStyle = greenPeaColors[colorIdx]; ctx.beginPath();
                for (let i = 0; i < settledPeas.length; i++) {
                    const pea = settledPeas[i];
                    if (pea.isGreen) {
                        // Handle smooth movement animation
                        if (pea.isMoving) {
                            const elapsed = performance.now() - pea.moveStartTime;
                            const moveDuration = 300; // 300ms smooth transition
                            if (elapsed < moveDuration) {
                                const progress = elapsed / moveDuration;
                                // Ease out function for smooth deceleration
                                const easeProgress = 1 - Math.pow(1 - progress, 3);
                                pea.x = pea.startX + (pea.targetX - pea.startX) * easeProgress;
                                pea.y = pea.startY + (pea.targetY - pea.startY) * easeProgress;
                            } else {
                                // Animation complete
                                pea.x = pea.targetX;
                                pea.y = pea.targetY;
                                pea.col = pea.targetCol;
                                pea.row = pea.targetRow;
                                pea.isMoving = false;
                                occupyGrid(pea.col, pea.row);
                            }
                        }
                        
                        // Skip drawing if blinking (will be drawn red separately)
                        if (pea.isBlinking) continue;
                        
                        const peaColorIdx = pea.colorIndex !== undefined ? pea.colorIndex : i % greenPeaColors.length;
                        if (peaColorIdx === colorIdx) { 
                            // Calculate radius with pulse effect
                            let radius = PEA_RADIUS;
                            if (pea.isPulsating && pea.pulseDuration > 0) {
                                // Pulse from 0.5x to 1.3x and back to 1x
                                const progress = Math.min(pea.pulseTime / pea.pulseDuration, 1);
                                const pulseScale = progress < 0.5 
                                    ? 0.5 + (progress * 2) * 0.8  // 0.5 -> 1.3
                                    : 1.3 - ((progress - 0.5) * 2) * 0.3; // 1.3 -> 1.0
                                radius = PEA_RADIUS * pulseScale;
                            }
                            // Ensure radius is positive
                            radius = Math.max(0.1, radius);
                            ctx.moveTo(pea.x + radius, pea.y); 
                            ctx.arc(pea.x, pea.y, radius, 0, Math.PI * 2); 
                        }
                    }
                }
                // Draw falling green peas
                for (let i = 0; i < peas.length; i++) {
                    const pea = peas[i];
                    if (pea.isGreen) {
                        const peaColorIdx = pea.colorIndex !== undefined ? pea.colorIndex : i % greenPeaColors.length;
                        if (peaColorIdx === colorIdx) { ctx.moveTo(pea.x + PEA_RADIUS, pea.y); ctx.arc(pea.x, pea.y, PEA_RADIUS, 0, Math.PI * 2); }
                    }
                }
                ctx.fill();
            }
            
            // Draw blinking red peas (peas being removed)
            ctx.fillStyle = '#d32f2f';
            ctx.beginPath();
            for (let i = 0; i < settledPeas.length; i++) {
                const pea = settledPeas[i];
                if (pea.isBlinking) {
                    const elapsed = performance.now() - pea.blinkStartTime;
                    const blinkCycle = Math.floor(elapsed / 100); // Blink every 100ms
                    if (blinkCycle % 2 === 0) { // Show on even cycles
                        ctx.moveTo(pea.x + PEA_RADIUS, pea.y);
                        ctx.arc(pea.x, pea.y, PEA_RADIUS, 0, Math.PI * 2);
                    }
                }
            }
            ctx.fill();
            
            // Draw sponge (üßΩ emoji) - LAST so it's on top of everything
            // Base calendar size of the current active month
            const cal = calendars[currentActiveMonth];
            const calendarSize = cal ? cal.size : 80;

            // Sponge = 45% of the calendar width
            const spongeSize = calendarSize * 0.45;
            
            ctx.font = `${spongeSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Tutorial animation - wiggle sponge if tutorial is showing
            let spongeDisplayX = sponge.x;
            let spongeDisplayY = sponge.y;
            const shouldWiggle = (showTutorial || spongeWiggleAfterCatch) && !sponge.isDragging;
            if (shouldWiggle && calendars[currentActiveMonth]) {
                // Animate sponge wiggling left-right
                const baseTime = spongeWiggleAfterCatch ? spongeWiggleStartTime : tutorialStartTime;
                const elapsed = performance.now() - baseTime;
                const animDuration = 800; // 0.8 second cycle
                const cycle = (elapsed % animDuration) / animDuration;
                
                // Simple left-right wiggle using sine wave
                const wiggleProgress = Math.sin(cycle * Math.PI * 2); // Oscillates between -1 and 1
                
                // Small horizontal wiggle
                const wiggleAmplitude = 10; 
                spongeDisplayX = sponge.x + wiggleProgress * wiggleAmplitude;
            }
            
            // Set opacity to 100%
            if (spongeVisible) {
                ctx.globalAlpha = 1.0;
                ctx.fillText('üßΩ', spongeDisplayX, spongeDisplayY);
                ctx.globalAlpha = 1.0; // Reset to default
            }
    


   


            // Draw golden peas
            for (let colorIdx = 0; colorIdx < peaColors.length; colorIdx++) {
                ctx.fillStyle = peaColors[colorIdx]; ctx.beginPath();
                for (let i = 0; i < settledPeas.length; i++) {
                    const pea = settledPeas[i];
                    if (!pea.isGreen) {
                        const peaColorIdx = pea.colorIndex !== undefined ? pea.colorIndex : i % peaColors.length;
                        if (peaColorIdx === colorIdx) { ctx.moveTo(pea.x + PEA_RADIUS, pea.y); ctx.arc(pea.x, pea.y, PEA_RADIUS, 0, Math.PI * 2); }
                    }
                }
                for (let i = 0; i < peas.length; i++) {
                    const pea = peas[i]; 
                    if (!pea.isGreen && i % peaColors.length === colorIdx) { 
                        ctx.moveTo(pea.x + PEA_RADIUS, pea.y); ctx.arc(pea.x, pea.y, PEA_RADIUS, 0, Math.PI * 2); 
                    }
                }
                ctx.fill();
            }
            



            // Draw horizontal indicator lines every 10,000 peas
            if (animationComplete) {
                const rowsPer10k = Math.floor(10000 / gridCols);

                ctx.strokeStyle = "rgba(0,0,0,0.75)";
                ctx.lineWidth = 5;
                ctx.fillStyle = "rgba(0,0,0,0.75)";
                ctx.font = "bold 16px Arial";
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";

                for (let row = rowsPer10k; row < (gridRows - rowsPer10k); row += rowsPer10k) {

                    // Flipped Y coordinate because your stack grows upward visually
                    const y = (gridRows - row) * GRID_CELL_SIZE;

                    // Draw the line
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();

                    // Rounded label
                    const peasAtThisLine = row * gridCols;
                    const rounded = Math.round(peasAtThisLine / 10000) * 10000;
                    const label = rounded.toLocaleString('de-CH');

                    // ------ Draw Label Background Box ------

                    const paddingX = 6;   // horizontal padding
                    const paddingY = 2;   // vertical padding
                    const offsetY  = -10; // move box + text above the line

                    const textWidth = ctx.measureText(label).width;
                    const boxX = 5 - paddingX;
                    const boxY = y - (16 + paddingY * 2);

                    const boxWidth = textWidth + paddingX * 2;
                    const boxHeight = 16 + paddingY * 2; // matches your 16px font size

                    // background box
                    ctx.fillStyle = "rgba(0,0,0,0.75)";
                    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

                    // Draw the text 
                    ctx.fillStyle = "rgba(255,255,255,1)";
                    ctx.fillText(label, 5, y + offsetY);
                }
            }
        }


        let lastFrameTime = performance.now();
        const targetFPS = 30;
        const frameInterval = 1000 / targetFPS;
        let lastDrawTime = lastFrameTime;
        let frameDeltaSeconds = frameInterval / 1000;
        
        function animate() { 
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            const shouldTick = !animationComplete && deltaTime >= frameInterval;
            const needsPassiveDraw = erbsenNotification || isCleaningInProgress || showTutorial || gameOver || monsterGhosts.length > 0 || (monster && (monster.waitForScrub && !monster.startedMoving));
            
            if (shouldTick) {
                lastFrameTime = currentTime - (deltaTime % frameInterval);
            }
            
            if (shouldTick || needsPassiveDraw) {
                frameDeltaSeconds = Math.min(0.1, (currentTime - lastDrawTime) / 1000);
                lastDrawTime = currentTime;
                update();
                draw();
            }
            
            requestAnimationFrame(animate); 
        }

        
        function showAchievementAlert() {
            if (!achievementAlert) return;
            achievementAlert.classList.add('visible');
        }

        function hideAchievementAlert() {
            if (!achievementAlert) return;
            achievementAlert.classList.remove('visible');
        }

        function showTaxPopup() {
            if (currentYear !== 1) return;
            const overlay = document.getElementById('tax-overlay');
            const popup = document.getElementById('tax-popup');
            const text = document.getElementById('tax-popup-text');
            const button = document.getElementById('tax-popup-button');
            const title = document.getElementById('tax-popup-title');
            
            taxPopupStep = 1;
            
            // First message - show yearly peas earned (not money)
            title.textContent = 'üèõÔ∏è Steueramt';
            text.textContent = `Wir sehen, Sie haben dieses Jahr ${yearlyPeasEarned} Erbsen verdient. Daf√ºr haben Sie sicher hart gearbeitet?`;
            button.textContent = 'Ja';
            
            overlay.classList.add('visible');
            popup.classList.add('visible');
        }
        
        function showHeritagePopup() {
            const overlay = document.getElementById('tax-overlay');
            const popup = document.getElementById('tax-popup');
            const text = document.getElementById('tax-popup-text');
            const button = document.getElementById('tax-popup-button');
            const title = document.getElementById('tax-popup-title');
            
            taxPopupStep = 100; // Special code for heritage event
            
            title.textContent = 'üí∞ Erbs-schaft';
            text.innerHTML = 'Anruf von der Familie: Du erh√§lst eine <b>Erbs-schaft von 50 Millionen CHF</b> (50\'000 Erbsen)';
            button.textContent = 'OK';
            
            if (!monsterCatchOccurred) {
                showAchievementAlert();
            } else {
                hideAchievementAlert();
            }
            
            overlay.classList.add('visible');
            popup.classList.add('visible');
        }
        
        function showPostCascadeTaxPopup() {
            const overlay = document.getElementById('tax-overlay');
            const popup = document.getElementById('tax-popup');
            const text = document.getElementById('tax-popup-text');
            const button = document.getElementById('tax-popup-button');
            const title = document.getElementById('tax-popup-title');
            
            taxPopupStep = 200; // Special code for post-cascade tax event
            
            title.textContent = 'üèõÔ∏è Steueramt';
            text.textContent = "Wir sehen, Sie haben auf einen Schlag 50'000 Erbsen verdient. Daf√ºr haben Sie sicher hart gearbeitet?";
            button.textContent = 'Nein';
            button.classList.add('no-button');
            
            overlay.classList.add('visible');
            popup.classList.add('visible');
        }
        
        function triggerHeritageEvent(reason) {
            if (heritageEventTriggered) return false;
            heritageEventTriggered = true;
            forcedHeritagePlan = null;
            suppressMonsterMovement();
            setTimeout(() => {
                showHeritagePopup();
            }, 500);
            return true;
        }

        function scheduleForcedHeritagePlan(targetMonthIndex, targetYear) {
            if (typeof targetMonthIndex === 'number' && typeof targetYear === 'number') {
                forcedHeritagePlan = {
                    monthIndex: targetMonthIndex,
                    year: targetYear
                };
                return;
            }
            const nextMonthIndex = (currentActiveMonth + 1) % 12;
            const wrapsYear = currentActiveMonth + 1 >= 12;
            const computedYear = currentYear + (wrapsYear ? 1 : 0);
            forcedHeritagePlan = {
                monthIndex: nextMonthIndex,
                year: computedYear
            };
        }

        function getUpcomingMonthReference() {
            const normalizedMonth = ((currentActiveMonth % 12) + 12) % 12;
            const yearOffset = Math.floor(currentActiveMonth / 12);
            return {
                monthIndex: normalizedMonth,
                year: currentYear + yearOffset
            };
        }

        function completeMonthAfterCatch(monthIndex) {
            const calendar = calendars[monthIndex];
            if (calendar && !calendar.isClean) {
                calendar.isClean = true;
                calendar.isDirty = false;
                calendar.progress = 1;
                calendar.scrubbingDistance = distancePerProgress;
                calendar.shineActive = false;
                calendar.shineProgress = 0;
                calendar.pop = 0;
            }
            if (currentActiveMonth <= monthIndex) {
                currentActiveMonth = monthIndex + 1;
            }
            if (currentActiveMonth > 12) {
                currentActiveMonth = 12;
            }
            moveSpongeToActiveMonthCenter();
        }

        function moveSpongeToActiveMonthCenter() {
            if (currentActiveMonth >= 12) return;
            const calendar = calendars[currentActiveMonth];
            if (!calendar) return;
            sponge.x = calendar.x + calendar.size / 2;
            sponge.y = calendar.y + calendar.size / 2;
        }

        function maybeTriggerForcedHeritageAfterCleaning(monthIndex, year) {
            if (!forcedHeritagePlan) return false;
            if (forcedHeritagePlan.monthIndex === monthIndex && forcedHeritagePlan.year === year) {
                forcedHeritagePlan = null;
                return triggerHeritageEvent('cleaned');
            }
            return false;
        }

        function maybeTriggerGuaranteedHeritage(monthIndex, year) {
            if (heritageEventTriggered) return false;
            if (year === 2 && monthIndex === 11) {
                return triggerHeritageEvent('december-guarantee');
            }
            return false;
        }
        
        function handleDebtChoice(choice) {
            hideGameOverPopup();
            const yearCompleted = currentActiveMonth >= 12;
            const upcomingMonth = getUpcomingMonthReference();
            gameOver = false;
            monsterDelayedAfterCatch = true;
            spongeWiggleAfterCatch = true;
            spongeWiggleStartTime = performance.now();
            scheduleForcedHeritagePlan(upcomingMonth.monthIndex, upcomingMonth.year);
            isCleaningInProgress = false;
            sponge.isDragging = false;
            showTutorial = false;
            tutorialShown = true;
            syncTutorialOverlay();
            hideAchievementAlert();
            moveSpongeToActiveMonthCenter();
            ensureMonsterPresence();
            if (yearCompleted && taxPopupStep === 0 && currentYear === 1) {
                setTimeout(() => {
                    if (taxPopupStep === 0) {
                        showTaxPopup();
                    }
                }, 500);
            }
        }
        
        function handleTaxPopupButton() {

            const overlay = document.getElementById('tax-overlay');
            const popup = document.getElementById('tax-popup');
            const text = document.getElementById('tax-popup-text');
            const button = document.getElementById('tax-popup-button');
            button.classList.remove('no-button');
            
            if (taxPopupStep === 100) {
                // Heritage event - start cascade
                overlay.classList.remove('visible');
                popup.classList.remove('visible');
                hideAchievementAlert();
                taxPopupStep = 0;
                heritageEventTriggered = true;
                currentMoney += 50000000
                spongeVisible = false;
                
                // Start the cascade animation
                manualMode = false;
                animationPaused = false;
                
                // Mark that we should show special tax popup after cascade
                setTimeout(() => {
                    checkCascadeCompletion();
                }, 100);
                
            } else if (taxPopupStep === 200) {
                // Post-cascade tax event - first stage (Nein button)
                taxPopupStep = 201;
                text.textContent = 'Achso... dann interessiert uns das nicht.';
                button.textContent = 'OK';
                
            } else if (taxPopupStep === 201) {
                // Post-cascade tax event - second stage (OK button)
                overlay.classList.remove('visible');
                popup.classList.remove('visible');
                taxPopupStep = 0;
                
                // Show restart & info button and allow scroll hint
                allowResetButtonsReveal = true;
                allowScrollIndicatorReveal = true;
                updateScrollIndicator();
                
            } else if (taxPopupStep === 1) {
                // Show second message
                taxPopupStep = 2;
                text.innerHTML = 'Gerne verrechnen wir ihnen <b>5 Erbsen Einkommenssteuer.</b> Sie werden direkt von ihrem Konto abgebucht. Vielen Dank f√ºr ihren wertvollen Beitrag zu unserer Gesellschaft!';
                button.textContent = 'OK';
            } else if (taxPopupStep === 2) {
                // Close popup and apply tax
                overlay.classList.remove('visible');
                popup.classList.remove('visible');
                taxPopupStep = 0;
                
                // Remove 5 green peas
                const greenPeas = settledPeas.filter(p => p.isGreen);
                if (greenPeas.length >= 5) {
                    // Sort by row then column (top-left first)
                    greenPeas.sort((a, b) => {
                        if (a.row !== b.row) return a.row - b.row;
                        return a.col - b.col;
                    });
                    
                    const peasToRemove = greenPeas.slice(0, 5);
                    
                    // Mark peas for blinking
                    peasToRemove.forEach(pea => {
                        pea.isBlinking = true;
                        pea.blinkStartTime = performance.now();
                    });
                    
                    // Trigger "-5 Erbsen" notification when blinking starts
                    erbsenNotification = {
                        text: '-5 Erbsen',
                        opacity: 1.0,
                        offsetY: 0,
                        startTime: performance.now(),
                        isNegative: true
                    };
                    
                    // After blinking, remove peas and money
                    setTimeout(() => {
                        // Remove the peas
                        peasToRemove.forEach(pea => {
                            const index = settledPeas.indexOf(pea);
                            if (index > -1) {
                                settledPeas.splice(index, 1);
                                occupiedGrid.delete(getGridKey(pea.col, pea.row));
                            }
                        });
                        
                        // Subtract money (5000 for 5 peas)
                        currentMoney -= 5000;
                        
                        // Reposition remaining green peas
                        repositionGreenPeas();
                        
                        // Update placement index
                        const remainingGreenPeas = settledPeas.filter(p => p.isGreen).length;
                        greenPeaPlacementIndex = remainingGreenPeas;
                        
                        // Reset calendars and increment year
                        resetCalendarsForNewYear();
                    }, RED_BLINK_TIME);
                }
            }
        }
        
        function resetCalendarsForNewYear() {
            spongeWiggleAfterCatch = false;
            spongeWiggleStartTime = 0;
            if (currentYear >= 2) {
                currentYear = 2;
                return;
            }
            // Reset all calendars to dirty state and clear their progress
            calendars.forEach(calendar => {
                calendar.isClean = false;
                calendar.isDirty = true;
                calendar.progress = 0;
                calendar.scrubbingDistance = 0;
            });
            
            // Reset to January
            currentActiveMonth = 0;
            cleaningProgress = 0;
            isCleaningInProgress = false;
            scrubbingDistance = 0;
            
            // Reset yearly peas counter for next year
            yearlyPeasEarned = 0;
            monster = null;
            monsterGhosts = [];
            monsterSuppressed = false;
            monsterDelayedAfterCatch = false;
            
            // Increment year
            currentYear++;

            // Trigger second tutorial at start of year 2
            if (currentYear === 2) {
                // Restore sponge to starting position (January calendar)
                const january = calendars[0];
                if (january) {
                    sponge.x = january.x + january.size / 2;
                    sponge.y = january.y + january.size / 2;
                }

                // Switch to tutorial phase 2  
                tutorialPhase = 2;
                tutorialShown = false;   // allow it to show again
                showTutorial = true;     // show immediately
                tutorialStartTime = performance.now();
                syncTutorialOverlay();
            }
            
            // Redraw to show new state
            draw();
        }
        
        function checkCascadeCompletion() {
            // Check if animation has completed
            if (animationComplete) {
                // Animation already complete, show tax popup after delay and block scrolling meanwhile
                document.body.style.overflow = 'hidden';
                setTimeout(() => {
                    showPostCascadeTaxPopup();
                    document.body.style.overflow = 'scroll';
                }, postCascadeTaxDelay);
            } else {
                // Keep checking every 100ms
                setTimeout(() => {
                    checkCascadeCompletion();
                }, 100);
            }
        }

        function reset() {
            peas = []; settledPeas = []; spawnedCount = 0; frameCount = 0; currentBatchIndex = 0; occupiedGrid.clear(); lastSpawnTime.clear(); initializeSpawnOrder();
            animationComplete = false; 
            manualMode = true;
            animationPaused = manualMode;
            greenPeaPlacementIndex = 0;
            currentMoney = 0;
            spongeVisible = true;
            lastFrameTime = performance.now();
            resetCanvasToViewport(); 
            gridCols = calcGridCols(); 
            gridRows = calcGridRows();
            recalcDistancePerProgress();
            monster = null;
            monsterGhosts = [];
            monsterSuppressed = false;
            gameOver = false;
            hideGameOverPopup();
            
            // Reset year

            currentYear = 1;

            // Reset calendar and sponge state
            calendars = [];
            currentActiveMonth = 0;
            cleaningProgress = 0;
            isCleaningInProgress = false;
            sponge = { x: 0, y: 0, isDragging: false, offsetX: 0, offsetY: 0 };
            
            // Reset scrubbing state
            lastSpongeX = 0;
            lastSpongeY = 0;
            scrubbingDistance = 0;
            
            // Reset yearly peas counter
            yearlyPeasEarned = 0;
            
            // Reset tutorial
            tutorialShown = false;
            showTutorial = false;
            tutorialStartTime = performance.now();
            if (tutorialTimeout) clearTimeout(tutorialTimeout);
            startTutorialTimer();
            syncTutorialOverlay();
            
            // Reset tax popup
            taxPopupStep = 0;
            document.getElementById('tax-overlay').classList.remove('visible');
            document.getElementById('tax-popup').classList.remove('visible');
            hideAchievementAlert();
            
            // Reset heritage event state
            heritageEventTriggered = false;
            forcedHeritagePlan = null;
            monsterCatchOccurred = false;
            monsterDelayedAfterCatch = false;
            spongeWiggleAfterCatch = false;
            spongeWiggleStartTime = 0;
            
            // Hide restart & info button
            document.getElementById('restart-btn').style.visibility = 'hidden';
            document.getElementById('info-btn').style.visibility = 'hidden';
            
            document.body.style.overflow = 'hidden'; window.scrollTo({ top: 0, behavior: 'auto' }); scrollIndicator.classList.add('hidden'); 
            allowScrollIndicatorReveal = false;
            draw(); // Draw empty canvas
        }
        
        // Start tutorial timer
        function startTutorialTimer() {
            if (tutorialTimeout) clearTimeout(tutorialTimeout);
            tutorialTimeout = setTimeout(() => {
                if (!tutorialShown && currentActiveMonth === 0 && !calendars[0]?.isClean) {
                    showTutorial = true;
                    tutorialStartTime = performance.now();
                    syncTutorialOverlay();
                }
            }, TUTORIAL_DELAY);
        }
        
        // Dismiss tutorial
        function dismissTutorial() {
            if (showTutorial) {
                showTutorial = false;
                tutorialShown = true;
                if (tutorialTimeout) clearTimeout(tutorialTimeout);
                syncTutorialOverlay();
            }
        }

        function updateScrollIndicator() {
            if (!animationComplete || !allowScrollIndicatorReveal) { scrollIndicator.classList.add('hidden'); return; }
            const scrollPosition = window.scrollY;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            const restartBtn = document.getElementById("restart-btn");
            const infoBtn    = document.getElementById("info-btn");
            // Hide if scrolled up more than 100px from bottom
            if (scrollPosition < maxScroll - 100) {
                scrollIndicator.classList.add('hidden');
                // make visible
                restartBtn.style.visibility = "visible";
                infoBtn.style.visibility = "visible";

                // fade them in on next frame
                requestAnimationFrame(() => {
                    restartBtn.style.opacity = "1";
                    infoBtn.style.opacity = "1";
                });

                resetButtonsShown = true;
            } else {
                scrollIndicator.classList.remove('hidden');
            }
        }

        
        // Mouse/touch event handlers for sponge
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top + window.scrollY
            };
        }
        
        function isSpongeClicked(mouseX, mouseY) {
            const spongeRadius = 30; // Half of sponge size (60/2)
            const dx = mouseX - sponge.x;
            const dy = mouseY - sponge.y;
            return Math.sqrt(dx * dx + dy * dy) < spongeRadius;
        }
        
        function checkSpongeCalendarCollision() {
            if (currentActiveMonth >= 12) return false;
            
            const activeCalendar = calendars[currentActiveMonth];
            if (!activeCalendar || activeCalendar.isClean) return false;
            
            // Check if sponge is over the active calendar
            return sponge.x > activeCalendar.x && 
                   sponge.x < activeCalendar.x + activeCalendar.size &&
                   sponge.y > activeCalendar.y && 
                   sponge.y < activeCalendar.y + activeCalendar.size;
        }
        
        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            if (isPointInMenuButton(pos.x, pos.y)) {
                window.location.href = 'index.html';
                return;
            }
            if (gameOver) return;
            
            
            if (isSpongeClicked(pos.x, pos.y)) {
                dismissTutorial();
                spongeWiggleAfterCatch = false;
                sponge.isDragging = true;
                sponge.offsetX = pos.x - sponge.x;
                sponge.offsetY = pos.y - sponge.y;
                canvas.style.cursor = 'grabbing';
                
                // Reset scrubbing tracking
                lastSpongeX = sponge.x;
                lastSpongeY = sponge.y;
                
                // Cancel tutorial timer when user starts interacting
                if (tutorialTimeout) clearTimeout(tutorialTimeout);
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            const overMenuButton = isPointInMenuButton(pos.x, pos.y);
            const previousHover = menuButtonHover;
            menuButtonHover = overMenuButton && !sponge.isDragging && !gameOver;
            if (previousHover !== menuButtonHover) {
                draw();
            }

            if (gameOver) {
                canvas.style.cursor = overMenuButton ? 'pointer' : 'default';
                return;
            }
            
            if (sponge.isDragging) {
                const newX = pos.x - sponge.offsetX;
                const newY = pos.y - sponge.offsetY;
                
                // Calculate movement distance for scrubbing
                if (lastSpongeX !== 0 && lastSpongeY !== 0) {
                    const dx = newX - lastSpongeX;
                    const dy = newY - lastSpongeY;
                    const movementDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Only count significant movements
                    if (movementDistance >= SCRUBBING_THRESHOLD) {
                        // Check if over active calendar
                        if (checkSpongeCalendarCollision()) {
                            const calendar = calendars[currentActiveMonth];
                            // Add to calendar's individual scrubbing distance
                            calendar.scrubbingDistance += movementDistance;
                            
                            // Start cleaning if not already started
                            if (!isCleaningInProgress) {
                                isCleaningInProgress = true;
                            }
                        } else {
                            // Stop cleaning if moved off calendar, but DON'T reset progress
                            if (isCleaningInProgress) {
                                isCleaningInProgress = false;
                            }
                        }
                    }
                }
                
                lastSpongeX = newX;
                lastSpongeY = newY;
                sponge.x = newX;
                sponge.y = newY;
                
                draw();
            } else {
                if (overMenuButton) {
                    canvas.style.cursor = 'pointer';
                    return;
                }
                // Change cursor if hovering over sponge
                if (isSpongeClicked(pos.x, pos.y)) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            if (gameOver) return;
            sponge.isDragging = false;
            canvas.style.cursor = 'default';
            
            // Reset scrubbing tracking
            lastSpongeX = 0;
            lastSpongeY = 0;
            
            // Stop cleaning flag but DON'T reset progress
            if (isCleaningInProgress) {
                isCleaningInProgress = false;
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
            const hadHover = menuButtonHover;
            menuButtonHover = false;
            if (hadHover) {
                draw();
            }
            if (gameOver) return;
            if (sponge.isDragging) {
                sponge.isDragging = false;
                canvas.style.cursor = 'default';
                
                // Stop cleaning flag but DON'T reset progress
                if (isCleaningInProgress) {
                    isCleaningInProgress = false;
                }
            }
        });
        
        // Touch event handlers for mobile
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0] || e.changedTouches[0];
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top + window.scrollY
            };
        }
        
canvas.addEventListener('touchstart', (e) => {
    const pos = getTouchPos(e);
    if (isPointInMenuButton(pos.x, pos.y)) {
        window.location.href = 'index.html';
        return;
    }
    if (gameOver) return;

    if (isSpongeClicked(pos.x, pos.y)) {
        dismissTutorial();
        spongeWiggleAfterCatch = false;
        e.preventDefault();
        sponge.isDragging = true;
        sponge.offsetX = pos.x - sponge.x;
        sponge.offsetY = pos.y - sponge.y;

        lastSpongeX = sponge.x;
        lastSpongeY = sponge.y;

        if (tutorialTimeout) clearTimeout(tutorialTimeout);
    }
});

canvas.addEventListener('touchmove', (e) => {
    if (gameOver || !sponge.isDragging) return;

    e.preventDefault(); 
    const pos = getTouchPos(e);

    const newX = pos.x - sponge.offsetX;
    const newY = pos.y - sponge.offsetY;

    if (lastSpongeX !== 0 && lastSpongeY !== 0) {
        const dx = newX - lastSpongeX;
        const dy = newY - lastSpongeY;
        const movementDistance = Math.sqrt(dx*dx + dy*dy);

        if (movementDistance >= SCRUBBING_THRESHOLD) {
            if (checkSpongeCalendarCollision()) {
                const cal = calendars[currentActiveMonth];
                cal.scrubbingDistance += movementDistance;

                if (!isCleaningInProgress) isCleaningInProgress = true;
            } else {
                if (isCleaningInProgress) isCleaningInProgress = false;
            }
        }
    }

    lastSpongeX = newX;
    lastSpongeY = newY;
    sponge.x = newX;
    sponge.y = newY;

    draw();
});

canvas.addEventListener('touchend', () => {
    if (gameOver) return;
    if (sponge.isDragging) {
        sponge.isDragging = false;
        if (isCleaningInProgress) isCleaningInProgress = false;
        lastSpongeX = 0;
        lastSpongeY = 0;
    }
});

// New: handle OS/browser interruptions
canvas.addEventListener('touchcancel', () => {
    if (gameOver) return;
    if (sponge.isDragging) {
        sponge.isDragging = false;
        if (isCleaningInProgress) isCleaningInProgress = false;
        lastSpongeX = 0;
        lastSpongeY = 0;
    }
});

        // New: handle OS/browser interruptions
        canvas.addEventListener('touchcancel', () => {
            if (gameOver) return;
            if (sponge.isDragging) {
                sponge.isDragging = false;
                if (isCleaningInProgress) isCleaningInProgress = false;
                lastSpongeX = 0;
                lastSpongeY = 0;
            }
        });

        window.addEventListener('scroll', () => {
            updateScrollIndicator();
        })



        window.addEventListener('resize', () => { 
            if (!animationComplete) { 
                resetCanvasToViewport(); 
                gridCols = calcGridCols(); 
                gridRows = calcGridRows(); 
            }
            recalcDistancePerProgress();
        });

        document.getElementById('tax-popup-button').addEventListener('click', handleTaxPopupButton);
        document.getElementById('restart-btn').addEventListener('click', () => {
            window.location.href = "index.html";
        });
        document.getElementById('info-btn').addEventListener('click', () => {
            window.location.href = "info.html";
        });
        if (gameOverOptions && gameOverOptions.length) {
            gameOverOptions.forEach(button => {
                button.addEventListener('click', () => handleDebtChoice(button.dataset.choice));
            });
        }

        // Start animation loop (will be paused in manual mode until cascade button is pressed)
        animationPaused = manualMode;
        
        // Start tutorial timer
        startTutorialTimer();
        
        draw(); // Draw initial state
        animate();
    </script>
</body>
</html>