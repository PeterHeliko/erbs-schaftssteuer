<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="icon" href="/favicon.png" type="image/png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teacher Game - Erbs-Schafts-Spiel</title>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&family=Caveat:wght@400;600&family=Gloria+Hallelujah&family=Shadows+Into+Light&family=Indie+Flower&family=Reenie+Beanie&family=Kalam&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        #canvas-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            min-height: 100vh;
            background: #2a2a2a;
        }
        canvas {
            display: block;
            background: #2a2a2a;
            width: 100%;
            max-width: 800px;
        }
        #top-bar {
            display: none;
        }
        #question-board {
            position: fixed;
            top: clamp(42px, 5vh, 72px);
            bottom: clamp(160px, 19vh, 240px);
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 28px);
            max-width: 760px;
            z-index: 60;
            pointer-events: none;
            overflow: hidden;
            display: flex;
            align-items: flex-start;
            padding: 4px 0;
            transition: opacity 0.35s ease;
        }
        #question-board::before,
        #question-board::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2;
        }
        #question-board::before {
            top: 0;
            height: 24px;
            background: linear-gradient(180deg, rgba(42,42,42,0.9), rgba(42,42,42,0));
        }
        #question-board::after {
            bottom: 0;
            height: 64px;
            background: linear-gradient(0deg, rgba(42,42,42,0.92), rgba(42,42,42,0));
        }

        #question-board.question-board--overflow::before,
        #question-board.question-board--overflow::after {
            opacity: 1;
        }
        #question-board.question-board--cascade {
            opacity: 0;
        }
        #question-list {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 3px;
            max-height: 100%;
            width: 100%;
            flex: 1 1 auto;
            padding: 24px 4px 0 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            scrollbar-width: none;
            position: relative;
        }
        #question-list::-webkit-scrollbar {
            display: none;
        }
        #question-list::after {
            content: '';
            display: block;
            flex: 0 0 auto;
            width: 100%;
            height: 96px;
        }
        .question-card {
            background: rgba(18, 18, 18, 0.92);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 12px 16px;
            color: #000000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
            transition: transform 0.25s ease, border-color 0.25s ease, background 0.25s ease;
        }
        .question-card.state-future,
        .question-card.state-done {
            padding: 6px 14px;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        .question-card.state-future {
            background: rgba(50, 50, 50, 0.8);
        }
        .question-card.state-done {
            background: rgba(35, 35, 35, 0.85);
            color: #bdbdbd;
        }
        .question-card.state-active {
            padding: 12px 18px;
            background: radial-gradient(circle at top, rgba(60, 60, 60, 0.35), rgba(10, 10, 10, 0.95));
            border: 1px solid rgba(255, 255, 255, 0.12);
        }
        .question-card.done-correct {
            border-color: #4CAF50;
        }
        .question-card.done-incorrect {
            border-color: #e53935;
        }
        .question-head {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            font-size: 14px;
        }
        .question-month {
            margin-right: auto;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
            color: #9ccc65;
            min-width: 70px;
        }
        .question-card.state-done .question-month {
            color: #9e9e9e;
        }
        .question-subject {
            margin-left: auto;
            flex: 1;
            text-align: right;
            font-weight: 600;
            font-size: 13px;
            color: #fff;
            margin-left: auto;
        }
        .question-card.state-done .question-subject {
            color: #c7c7c7;
        }
        .question-icon {
            position: absolute;
            left: 50%;
            transform: translate(-50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #1a1a1a;
            background: transparent;
        }
        .question-icon.correct {
            background: rgba(76, 175, 80, 0.25);
            color: #4CAF50;
        }
        .question-icon.incorrect {
            background: rgba(229, 57, 53, 0.25);
            color: #ef5350;
        }
        .question-body {
            margin-top: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            background: rgba(255, 240, 200, 0.8);
            line-height: 1.45;
            font-size: 14px;
        }
        .question-body p {
            margin: 0 0 8px 0;
        }
        .question-body p:last-child {
            margin-bottom: 0;
        }
        .question-answer {
            font-family: 'Patrick Hand', cursive;
            letter-spacing: 0.3px;
        }

        .question-actions {
            margin-top: 12px;
            display: flex;
            gap: 10px;
        }
        .decision-btn {
            flex: 1;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            cursor: pointer;
            color: #fff;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
            transition: background 0.18s ease, transform 0.18s ease, box-shadow 0.18s ease;
        }
        .decision-btn:disabled {
            opacity: 0.45;
            cursor: not-allowed;
            box-shadow: none;
        }
        .decision-btn:focus-visible {
            outline: 2px solid #ffeb3b;
            outline-offset: 2px;
        }
        .decision-btn.correct {
            background: #2e7d32;
        }
        .decision-btn.correct:hover:not(:disabled),
        .decision-btn.correct:focus-visible:not(:disabled) {
            background: #1f5b23;
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
        }
        .decision-btn.incorrect {
            background: #c62828;
        }
        .decision-btn.incorrect:hover:not(:disabled),
        .decision-btn.incorrect:focus-visible:not(:disabled) {
            background: #8e0000;
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
        }
        .question-card.state-future .question-body,
        .question-card.state-future .question-actions,
        .question-card.state-done .question-body,
        .question-card.state-done .question-actions {
            display: none;
        }
        .question-card.compact {
            font-size: 13px;
        }
        .question-sheet {
            margin: 4px 0 0;
            width: 100%;
            max-width: 360px;
            min-height: 120px;
            display: block;
        }
        .question-sheet svg {
            width: 100% !important;
            height: auto !important;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 8px;
            font-size: 12px;
            margin: 2px 0;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        button:hover:not(:disabled) {
            background: #45a049;
        }
        #scroll-indicator {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translate3d(-50%, 0, 0);
            width: min(80vw, 460px);
            background: rgba(0, 0, 0, 0.72);
            color: #FFD700;
            padding: 14px;
            border-radius: 16px;
            font-size: clamp(14px, 4vw, 16px);
            font-weight: 500;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(10px);
            text-align: center;
            opacity: 1;
            transition: opacity 0.45s ease, transform 0.45s ease;
            will-change: opacity, transform;
        }
        #scroll-indicator.hidden {
            opacity: 0;
            transform: translate3d(-50%, -24px, 0);
        }
        #tax-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 200;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        #tax-popup.visible {
            display: block;
            animation: popupAppear 0.3s ease-out;
        }
        @keyframes popupAppear {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        #tax-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 199;
        }
        #tax-overlay.visible {
            display: block;
        }
        #tax-popup h2 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 24px;
        }
        #tax-popup p {
            margin: 0 0 20px 0;
            color: #666;
            line-height: 1.5;
        }
        #tax-popup button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 30px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
        }
        #tax-popup button.no-button {
            background: #ae0c00;
        }
        #tax-popup button.no-button:hover {
            background: #ae0c00;
        }
        .tutorial-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: clamp(16px, 4vw, 48px);
            z-index: 150;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .tutorial-overlay.visible {
            opacity: 1;
        }
        .tutorial-overlay .tutorial-card {
            width: min(520px, 100%);
            background: rgba(0, 0, 0, 0.82);
            border: 2px solid #4CAF50;
            border-radius: 18px;
            padding: clamp(10px, 2.0vw, 16px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.45);
            color: #ffffff;
            text-align: center;
            transform: translateY(10px) scale(0.95);
            transition: transform 0.3s ease;
        }
        .tutorial-overlay.visible .tutorial-card {
            transform: translateY(0) scale(1);
        }
        .tutorial-overlay .tutorial-icon {
            font-size: clamp(32px, 6vw, 48px);
            margin-bottom: 12px;
        }
        .tutorial-overlay .tutorial-text p {
            margin: clamp(16px, 4vw, 20px);
            font-size: clamp(16px, 4vw, 20px);
            line-height: 1.4;
        }
        #restart-btn,
        #info-btn {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.8s ease;
            position: fixed;
            bottom: 20px;
            z-index: 300;
            background: rgba(26, 26, 26, 0.6);
            color: white;
            border: none;
            width: 105px;
            padding: 10px;
            cursor: pointer;
            border-radius: 10px;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #restart-btn { left: calc(50% - 115px); }
        #info-btn { right: calc(50% - 115px); }
    </style>
</head>
<body>
    <div id="canvas-container"><canvas id="canvas"></canvas></div>

    <div id="top-bar">
        <div id="year-display">Jahr 1</div>
        <div id="money-display">0.-</div>
    </div>

    <div id="question-board">
        <div id="question-list"></div>
    </div>
 
    <div id="scroll-indicator" class="hidden">Nach oben scrollen um deinen ganzen Reichtum zu entdecken</div>


    <div id="tutorial-overlay" class="tutorial-overlay" aria-hidden="false" aria-live="polite">
        <div class="tutorial-card">
            <div class="tutorial-icon" id="tutorial-icon">üìã</div>
            <div class="tutorial-text" id="tutorial-text"></div>
        </div>
    </div>

    <div id="tax-overlay"></div>
    <div id="tax-popup">
        <h2 id="tax-popup-title">üèõÔ∏è Steueramt</h2>
        <p id="tax-popup-text"></p>
        <button id="tax-popup-button"></button>
    </div>

    <button id="restart-btn">Hauptmen√º</button>
    <button id="info-btn">Mehr Info</button>

    <script src="https://cdn.jsdelivr.net/npm/vexflow@5.0.0/build/cjs/vexflow.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const scrollIndicator = document.getElementById('scroll-indicator');
        const tutorialOverlay = document.getElementById('tutorial-overlay');
        const tutorialText = document.getElementById('tutorial-text');
        const tutorialIcon = document.getElementById('tutorial-icon');
        const restartBtn = document.getElementById('restart-btn');
        const infoBtn = document.getElementById('info-btn');
        const taxOverlay = document.getElementById('tax-overlay');
        const taxPopup = document.getElementById('tax-popup');
        const taxPopupText = document.getElementById('tax-popup-text');
        const taxPopupButton = document.getElementById('tax-popup-button');
        const taxPopupTitle = document.getElementById('tax-popup-title');
        const questionBoard = document.getElementById('question-board');
        const questionList = document.getElementById('question-list');
 
        const TOP_BAR_HEIGHT = 42;
        const monthNames = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];

        const tutorialMessages = {
            1: { icon: 'üìã', text: 'Korrigiere die Pr√ºfungen! F√ºr jede korrigierte Frage wird dir dein Monatsgehalt ausgezahlt.' },
            2: { icon: 'üè¶', text: 'Platzhalter-Tutorial Jahr 2: Bleib dran bis Dezember, um das Erbe zu erleben.' }
        };

        // FONT SIZE CONFIGURATION
        // Easily adjust font sizes for each handwriting font used in exam answers
        const fontSizeConfig = {
            'Patrick Hand': 22,
            'Caveat': 24,
            'Gloria Hallelujah': 20,
            'Shadows Into Light': 22,
            'Indie Flower': 22,
            'Reenie Beanie': 30,
            'Kalam': 24
        };
 
        const examQuestions = [
            { subject: 'Mathematik', content: 'Eine Putzkraft verdient monatlich 4\'000 CHF. Wenn sie 20 Jahre Lang arbeitet, wie viel hat sie daf√ºr verdient?', answer: '50 Millionen' },
            { subject: 'Gesellschaft', content: 'Wof√ºr steht das sogenannte NEID-Argument im politischen Diskurs?', answer: 'Normalisierung extremer In√§quit√§ts-Dimensionen' },
            { subject: 'Musik', content: '', answer: '&emsp;E B F A F D&emsp;&emsp;A B G A B E', sheetMusic: 'ebfafd-abgabe' },
            { subject: 'Biologie', content: 'Welche Speisepflanze tr√§gt den wissenschaftlichen Namen "Pisum sativum"?', answer: 'Bohne' },
            { subject: 'Mathematik', content: `
<div style="display:flex; align-items:flex-start; gap:10px;">
  <div style="flex:1;">
    Ein Einfrankenst√ºck wiegt 4,4 gramm. Wie viel Gewicht tragen Betroffene der Erbschaftssteuerinitiative auf der Steuerflucht als Einfr√§nkler mindestens auf dem R√ºcken?
  </div>
  <img src="einfranken.png" style="width:60px;">
</div>
`, answer: '4.4g x 50\'000\'000 = 220 Tonnen'
 },
            { subject: 'Deutsch', content: 'Analysiere die Metapher: "Der Staat greift tief in die Taschen der Erben." Was impliziert diese Formulierung?', answer: 'Dass Erben zu tiefe Taschen haben' },
            { subject: 'Deutsch', content: 'Nenne ein M√§rchen von Hans Christian Andersen.', answer: 'Die Prinzessin auf der Erbschaft' },
            { subject: 'Chemie', content: 'Definiere den Begriff Diffusion.', answer: 'Diffusion bewirkt den Abbau von Konzentrationsunterschieden.' },
            { subject: 'Religion', content: 'Wo lebten Adam und Eva bevor sie von der Schlange verf√ºhrt wurden?', answer: 'Im Steuerparadies' },
            { subject: 'Englisch', content: '√úbersetze : harsh - stem - to steer', answer: 'herb Schaft steuern' },
            { subject: 'Chemie', content: 'Was sind sogenannte VOC-Emissionen?"', answer: 'Lautstarke √∂ffentliche √Ñusserungen von Steuerfl√ºchtigen organischen Verbindungen' }
        ];

        const ABGABE_EBBE_SEQUENCE = [
            { keys: ['e/4'], duration: 'q' },
            { keys: ['b/4'], duration: 'q', accidentals: [{ index: 0, type: 'b' }] },
            { keys: ['f/4'], duration: 'q',},
            { keys: ['a/4'], duration: 'q' },
            { keys: ['f/4'], duration: 'q',},
            { keys: ['d/4'], duration: 'q',},
            { rest: true, duration: 'qr' },
            { keys: ['a/4'], duration: 'q' },
            { keys: ['b/4'], duration: 'q', accidentals: [{ index: 0, type: 'b' }] },
            { keys: ['g/4'], duration: 'q' },
            { keys: ['a/4'], duration: 'q' },
            { keys: ['b/4'], duration: 'q', accidentals: [{ index: 0, type: 'b' }] },
            { keys: ['e/4'], duration: 'q' },            

        ];

        const SHEET_SEQUENCES = {
            'ebfafd-abgabe': ABGABE_EBBE_SEQUENCE
        };

        let currentYear = 1;

        let currentMonthIndex = 0;
        let yearlyPeasEarned = 0;
        let currentMoney = 0;
        let monthlyCompletionsLocked = false;
        let showTutorial = true;
        let tutorialPhase = 1;
        let questionScrollAdvanceQueued = false;
 
        const PEA_SIZE = 12;

        const PEA_RADIUS = PEA_SIZE / 2;
        const TOTAL_PEAS = 50000;
        const SPAWN_RATE = 675;
        const FALL_SPEED = 67.5;
        const RED_BLINK_TIME = 1000;
        const GRID_CELL_SIZE = PEA_SIZE;

        function calcGridCols() { return Math.max(1, Math.floor(canvas.width / GRID_CELL_SIZE)); }
        function calcGridRows() { return Math.max(1, Math.floor(canvas.height / GRID_CELL_SIZE)); }

        let gridCols = 0;
        let gridRows = 0;
        let columnsToSpawn = [];
        let currentBatchIndex = 0;
        const occupiedGrid = new Set();
        const lastSpawnTime = new Map();

        let peas = [];
        let settledPeas = [];
        let spawnedCount = 0;
        let frameCount = 0;
        let greenPeaPlacementIndex = 0;
        let erbsenNotification = null;

        const peaColors = ['#FFEB3B', '#FFD54F', '#FFCA28', '#FFC107', '#FFB300'];
        const greenPeaColors = ['#7CB342', '#8BC34A', '#9CCC65', '#AED581', '#689F38'];

        let animationComplete = false;
        let manualMode = true;
        let animationPaused = true;
        let allowScrollIndicatorReveal = false;
        let allowResetButtonsReveal = false;
        let resetButtonsShown = false;

        let taxPopupStep = 0;
        let heritageEventTriggered = false;
        let postCascadeTaxDelay = 1000;

        let lastFrameTime = performance.now();
        let lastDrawTime = performance.now();
        let frameDeltaSeconds = 0;
        const DRAW_INTERVAL = 1000 / 60;
        const TARGET_FPS   = 30;              // desired frame rate
        const FRAME_INTERVAL = 1000 / TARGET_FPS; // ‚âà33‚ÄØms per frame

        let menuButtonBounds = { x: 0, y: 0, width: 0, height: 0 };
        let menuButtonHover = false;

        resetCanvasToViewport();
        gridCols = calcGridCols();
        gridRows = calcGridRows();
        initializeSpawnOrder();
        greenPeaPlacementIndex = 0;
        syncTutorialOverlay();
        initializeQuestions();
 
        function resetCanvasToViewport() {

            canvas.width = Math.min(800, window.innerWidth);
            canvas.height = window.innerHeight;
        }

        function getGridKey(col, row) { return `${col},${row}`; }
        function isGridOccupied(col, row) {
            if (row >= gridRows) return true;
            if (col < 0 || col >= gridCols) return true;
            return occupiedGrid.has(getGridKey(col, row));
        }
        function occupyGrid(col, row) { occupiedGrid.add(getGridKey(col, row)); }

        function initializeSpawnOrder() {
            columnsToSpawn = [];
            for (let i = 0; i < TOTAL_PEAS; i++) {
                columnsToSpawn.push(i % gridCols);
            }
            for (let i = columnsToSpawn.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [columnsToSpawn[i], columnsToSpawn[j]] = [columnsToSpawn[j], columnsToSpawn[i]];
            }
        }

        function getGreenPeaArea() {
            const startRow = gridRows - 10;
            const endRow = gridRows;
            return {
                startRow,
                endRow,
                bgStartRow: startRow - 1
            };
        }

        function addMonthlyGreenPeas() {
            const greenArea = getGreenPeaArea();
            const lowerQuarterStartRow = greenArea.startRow;
            const maxRow = greenArea.endRow;
            const marginCols = 2;
            const startCol = marginCols;
            const endCol = gridCols - marginCols;
            const availableCols = Math.max(1, endCol - startCol);

            for (let i = 0; i < 9; i++) {
                const currentIndex = greenPeaPlacementIndex + i;
                setTimeout(() => {
                    const colOffset = currentIndex % availableCols;
                    const col = startCol + colOffset;
                    const row = lowerQuarterStartRow + Math.floor(currentIndex / availableCols);

                    if (row >= maxRow || isGridOccupied(col, row)) {
                        return;
                    }

                    const pea = {
                        x: col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                        y: row * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                        col,
                        row,
                        colorIndex: Math.floor(Math.random() * greenPeaColors.length),
                        settled: true,
                        isGreen: true,
                        isPulsating: true,
                        pulseTime: 0,
                        pulseDuration: 6,
                        baseRadius: PEA_RADIUS
                    };
                    settledPeas.push(pea);
                    occupyGrid(col, row);
                    currentMoney += 1000;

                    const pulseInterval = setInterval(() => {
                        pea.pulseTime++;
                        if (pea.pulseTime >= pea.pulseDuration) {
                            pea.isPulsating = false;
                            clearInterval(pulseInterval);
                        }
                        draw();
                    }, 16);
                }, i * 25);
            }

            greenPeaPlacementIndex += 9;
            erbsenNotification = {
                text: '+9 Erbsen',
                opacity: 1,
                offsetY: 0,
                startTime: performance.now(),
                isNegative: false
            };
        }

        function repositionGreenPeas() {
            const greenArea = getGreenPeaArea();
            const lowerQuarterStartRow = greenArea.startRow;
            const marginCols = 2;
            const startCol = marginCols;
            const endCol = gridCols - marginCols;
            const availableCols = Math.max(1, endCol - startCol);
 
            const greenPeas = settledPeas.filter(p => p.isGreen);
            greenPeas.forEach(pea => {
                occupiedGrid.delete(getGridKey(pea.col, pea.row));
            });
            greenPeas.sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row;
                return a.col - b.col;
            });
 
            greenPeas.forEach((pea, index) => {
                const colOffset = index % availableCols;
                const col = startCol + colOffset;
                const row = lowerQuarterStartRow + Math.floor(index / availableCols);
                pea.targetX = col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                pea.targetY = row * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                pea.isMoving = true;
                pea.moveStartTime = performance.now();
                pea.startX = pea.x;
                pea.startY = pea.y;
                pea.targetCol = col;
                pea.targetRow = row;
            });
        }
 
        function initializeQuestions() {
            examQuestions.forEach((question, idx) => {
                question.state = idx === 0 ? 'active' : 'future';
                question.userEvaluation = null;
            });
            renderQuestions();
        }
 
        function updateQuestionStates() {
            examQuestions.forEach((question, idx) => {
                if (idx < currentMonthIndex) {
                    question.state = 'done';
                } else if (idx === currentMonthIndex) {
                    question.state = 'active';
                } else {
                    question.state = 'future';
                    question.userEvaluation = null;
                }
            });
            renderQuestions();
        }
 
        function renderQuestions() {
            if (!questionList) return;
            questionList.innerHTML = '';
            examQuestions.forEach((question, idx) => {
                const card = document.createElement('div');
                const state = question.state || 'future';
                card.classList.add('question-card', `state-${state}`);
                if (state !== 'active') {
                    card.classList.add('compact');
                }
                if (state === 'done') {
                    const evalClass = question.userEvaluation === 'correct' ? 'done-correct' : 'done-incorrect';
                    card.classList.add(evalClass);
                }
                const icon = state === 'done'
                    ? `<div class="question-icon ${question.userEvaluation === 'correct' ? 'correct' : 'incorrect'}">${question.userEvaluation === 'correct' ? '‚úîÔ∏è' : '‚úñÔ∏è'}</div>`
                    : '';
                const header = `
                    <div class="question-head">
                        <div class="question-month">${monthNames[idx]}</div>
                        ${icon}
                        <div class="question-subject">${question.subject}</div>
                    </div>
                `;
                let questionContentHTML = '';
                if (question.content) {
                    questionContentHTML = `<p>${question.content}</p>`;
                }
                if (question.sheetMusic) {
                    questionContentHTML += `<div class="question-sheet" data-sheet="${question.sheetMusic}"></div>`;
                }
                const body = state === 'active'
                    ? `<div class="question-body">
                            ${questionContentHTML}
                            <p class="question-answer">${question.answer}</p>
                        </div>
                        <div class="question-actions">
                            <button class="decision-btn correct" data-choice="correct">Richtig</button>
                            <button class="decision-btn incorrect" data-choice="incorrect">Falsch</button>
                        </div>`
                    : '';
                card.innerHTML = header + body;
                if (state === 'active') {
                    const buttons = card.querySelectorAll('.decision-btn');
                    buttons.forEach(btn => {
                        btn.disabled = monthlyCompletionsLocked || heritageEventTriggered;
                        btn.addEventListener('click', () => handleQuestionDecision(idx, btn.dataset.choice));
                    });
                    if (question.sheetMusic) {
                        const sheetEl = card.querySelector('.question-sheet');
                        renderQuestionSheet(sheetEl, question.sheetMusic);
                    }
                }
                // List of handwriting fonts
                const handwritingFonts = [
                    'Patrick Hand', 
                    'Caveat', 
                    'Gloria Hallelujah', 
                    'Shadows Into Light',
                    'Indie Flower',
                    'Reenie Beanie',
                    'Kalam'
                ];

                // Apply random font to the answer text
                if (state === 'active') {
                    const answer = card.querySelector('.question-answer');
                    if (answer) {
                        const randomFont = handwritingFonts[Math.floor(Math.random() * handwritingFonts.length)];
                        answer.style.fontFamily = `'${randomFont}', cursive`;
                        // Apply font-specific size from configuration
                        answer.style.fontSize = (fontSizeConfig[randomFont] || 20) + 'px';
                    }
                }

                questionList.appendChild(card);
            });

            syncQuestionBoardWindow();
        }

        function renderQuestionSheet(target, sheetKey) {
            if (!target) return;
            const VF = window.VexFlow || (window.Vex && window.Vex.Flow);
            if (!VF) {
                requestAnimationFrame(() => renderQuestionSheet(target, sheetKey));
                return;
            }
            const sequence = SHEET_SEQUENCES[sheetKey];
            if (!sequence) return;
            drawSheetSequence(target, sequence, VF);
        }
 
        function drawSheetSequence(target, sequence, VF) {
            target.innerHTML = '';
            const rawWidth = target.clientWidth || target.offsetWidth || 260;
            const width = Math.min(440, Math.max(300, rawWidth));
            const height = 80;
            const renderer = new VF.Renderer(target, VF.Renderer.Backends.SVG);
            renderer.resize(width, height);
            const context = renderer.getContext();
            const stave = new VF.Stave(2, -20, width);
            stave.addClef('treble');
            stave.setEndBarType(VF.Barline.type.DOUBLE);
            stave.setContext(context).draw();
 
            const notes = sequence.map(spec => createSheetNote(spec, VF));
            const voice = new VF.Voice({ num_beats: notes.length, beat_value: 4 });
            voice.setMode(VF.Voice.Mode.SOFT);
            voice.addTickables(notes);
 
            voice.setMode(VF.Voice.Mode.FULL);
            new VF.Formatter().joinVoices([voice]).format([voice], width - 50);
            voice.draw(context, stave);
        }
 
        function createSheetNote(spec, VF) {
            const noteConfig = {
                keys: spec.keys || ['b/4'],
                duration: spec.duration,
                clef: 'treble'
            };
            const note = new VF.StaveNote(noteConfig);
            if (spec.rest) {
                note.addModifier(new VF.Annotation(''), 0);
            }
            (spec.accidentals || []).forEach(acc => {
                const accidental = new VF.Accidental(acc.type);
                note.addModifier(accidental, acc.index || 0);
            });
            return note;
        }


 
        function handleQuestionDecision(questionIndex, decision) {

            if (monthlyCompletionsLocked || heritageEventTriggered) return;
            const question = examQuestions[questionIndex];
            if (!question || question.state !== 'active') return;
            question.userEvaluation = decision === 'correct' ? 'correct' : 'incorrect';
            question.state = 'done';
            questionScrollAdvanceQueued = true;
            renderQuestions();
            handleMonthCompletion();
        }

        function syncQuestionBoardWindow() {
            if (!questionBoard || !questionList) return;
            requestAnimationFrame(() => {
                // If the element has no height yet, bail
                const viewportHeight = questionList.clientHeight;
                if (!viewportHeight) return;

                // Toggle overflow class as before (based on element scroll, not parent)
                const contentHeight = questionList.scrollHeight;
                questionBoard.classList.toggle('question-board--overflow', contentHeight > viewportHeight);

                const cards = Array.from(questionList.querySelectorAll('.question-card'));
                const upcomingCards = cards.filter(card => !card.classList.contains('state-done'));
                if (!upcomingCards.length) {
                    if (contentHeight <= viewportHeight) {
                        questionList.scrollTop = 0;
                    }
                    questionScrollAdvanceQueued = false;
                    return;
                }

                // Read safe margins (top/bottom) once ‚Äî keep them constants or derive from CSS
                const gradientTop = 24;
                const gradientBottom = 64;

                // Convert the safe region into viewport coordinates using the list bounding rect
                const listRect = questionList.getBoundingClientRect();

                // Helper: returns card rect relative to the list content area (top in pixels from content start)
                function cardRects(card) {
                    const cardRect = card.getBoundingClientRect();
                    // convert to coordinates relative to list's client box top
                    const topInList = (cardRect.top - listRect.top) + questionList.scrollTop;
                    const bottomInList = topInList + cardRect.height;
                    return { topInList, bottomInList, height: cardRect.height };
                }

                // Compute safe region (in list-content coordinates)
                const currentScroll = questionList.scrollTop;
                const safeTop = currentScroll + gradientTop;
                const safeBottom = currentScroll + viewportHeight - gradientBottom;

                // Determine first and last upcoming rectangles
                const firstUpcoming = upcomingCards[0];
                const lastUpcoming = upcomingCards[upcomingCards.length - 1];
                const firstRect = cardRects(firstUpcoming);
                const lastRect = cardRects(lastUpcoming);

                const maxScroll = Math.max(0, contentHeight - viewportHeight);
                let targetScroll = currentScroll;

                const CARD_GAP = 3;

                const futureOverflowBottom = lastRect.bottomInList > safeBottom + 0.5;

                if (questionScrollAdvanceQueued && futureOverflowBottom) {
                    // try to hide any 'done' card that overlaps the top safe area
                    const visibleDone = cards.find(card => {
                        if (!card.classList.contains('state-done')) return false;
                        const r = cardRects(card);
                        return (r.topInList < firstRect.topInList) && (r.bottomInList > safeTop);
                    });

                    if (visibleDone) {
                        const v = cardRects(visibleDone);
                        const hideThreshold = v.bottomInList + CARD_GAP;
                        targetScroll = Math.min(maxScroll, Math.max(targetScroll, hideThreshold - gradientTop));
                    } else {
                        // fallback shift: nudge down by the first upcoming height
                        targetScroll = Math.min(maxScroll, currentScroll + firstRect.height + CARD_GAP);
                    }
                    questionScrollAdvanceQueued = false;
                } else {
                    // Ensure first upcoming is not hidden behind top gradient
                    if (firstRect.topInList < safeTop - 0.5) {
                        targetScroll = Math.max(0, firstRect.topInList - gradientTop);
                    }
                    // Ensure last upcoming bottom is visible above bottom gradient
                    if (futureOverflowBottom) {
                        targetScroll = Math.min(maxScroll, lastRect.bottomInList - (viewportHeight - gradientBottom));
                    }
                    questionScrollAdvanceQueued = false;
                }

                // Ensure active card visible within safe region as final check
                const activeCard = questionList.querySelector('.question-card.state-active');
                if (activeCard) {
                    const a = cardRects(activeCard);
                    const allowedTop = targetScroll + gradientTop;
                    const allowedBottom = targetScroll + viewportHeight - gradientBottom;
                    if (a.topInList < allowedTop) {
                        targetScroll = Math.max(0, a.topInList - gradientTop);
                    } else if (a.bottomInList > allowedBottom) {
                        targetScroll = Math.min(maxScroll, a.bottomInList - (viewportHeight - gradientBottom));
                    }
                }

                targetScroll = Math.max(0, Math.min(maxScroll, Math.round(targetScroll)));
                questionList.scrollTop = targetScroll;
            });
        }



 
        function setQuestionBoardCascadeState(active) {

            if (!questionBoard) return;
            questionBoard.classList.toggle('question-board--cascade', Boolean(active));
        }
 
        function activateGreenPea(greenPea) {

            const columnsToCheck = [greenPea.col - 1, greenPea.col, greenPea.col + 1];
            const greenPeasToActivate = settledPeas.filter(p => p.isGreen && columnsToCheck.includes(p.col) && p.row >= greenPea.row);
            greenPeasToActivate.sort((a, b) => a.row - b.row);

            for (const pea of greenPeasToActivate) {
                const index = settledPeas.indexOf(pea);
                if (index > -1) {
                    settledPeas.splice(index, 1);
                }
                occupiedGrid.delete(getGridKey(pea.col, pea.row));
                pea.settled = false;
                pea.isFalling = true;
                pea.update = Pea.prototype.update;
                pea.settleInGrid = Pea.prototype.settleInGrid;
                peas.push(pea);
            }
        }

        class Pea {
            constructor(col) {
                this.col = col;
                this.x = col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                this.y = -PEA_RADIUS - Math.random() * 600;
                this.settled = false;
                this.isGreen = false;
                this.isFalling = false;
            }
            update() {
                if (this.settled) return;
                this.y += FALL_SPEED;
                const currentRow = Math.floor(this.y / GRID_CELL_SIZE);

                if (currentRow >= gridRows - 1) {
                    this.settleInGrid(this.col, gridRows - 1);
                    return;
                }

                if (!this.isGreen) {
                    const greenPeaInCurrentRow = settledPeas.find(p => p.isGreen && p.col === this.col && p.row === currentRow);
                    if (greenPeaInCurrentRow) {
                        activateGreenPea(greenPeaInCurrentRow);
                    }
                }

                const nextRow = currentRow + 1;
                const nextRowHasNonGreenPea = settledPeas.find(p => !p.isGreen && p.col === this.col && p.row === nextRow);
                if (nextRowHasNonGreenPea) {
                    this.settleInGrid(this.col, currentRow);
                }
            }
            settleInGrid(col, row) {
                if (isGridOccupied(col, row)) {
                    for (let r = row; r >= -4; r--) {
                        if (!isGridOccupied(col, r)) {
                            row = r;
                            break;
                        }
                    }
                }
                this.x = col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                this.y = row * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                this.row = row;
                this.settled = true;
                this.isFalling = false;
                occupyGrid(col, row);
            }
        }

        function spawnPeas() {
            const rate = Math.min(SPAWN_RATE, TOTAL_PEAS - spawnedCount);
            const MIN_SPAWN_GAP = 1;
            let spawned = 0;
            let attempts = 0;
            const maxAttempts = rate * 3;
            while (spawned < rate && spawnedCount < TOTAL_PEAS && attempts < maxAttempts) {
                attempts++;
                const col = columnsToSpawn[currentBatchIndex % columnsToSpawn.length];
                const lastSpawn = lastSpawnTime.get(col) || -Infinity;
                if (frameCount - lastSpawn >= MIN_SPAWN_GAP) {
                    peas.push(new Pea(col));
                    lastSpawnTime.set(col, frameCount);
                    spawnedCount++;
                    spawned++;
                }
                currentBatchIndex++;
            }
        }

        function isScreenFull() {
            const requiredRows = [-1, -2, -3, -4];
            for (const r of requiredRows) {
                for (let col = 0; col < gridCols; col++) {
                    if (!occupiedGrid.has(getGridKey(col, r))) return false;
                }
            }
            return true;
        }

        function generateCompleteStack() {
            gridCols = calcGridCols();
            gridRows = calcGridRows();
            const totalRows = Math.ceil(TOTAL_PEAS / gridCols);
            const totalHeight = totalRows * GRID_CELL_SIZE;
            const extraRowsAbove = Math.max(0, totalRows - gridRows);

            const visibleHeight = window.innerHeight;
            const visibleWidth = canvas.width;
            const visibleSnapshot = ctx.getImageData(0, 0, visibleWidth, visibleHeight);

            const preservedVisible = [];
            function addPreserved(pea) {
                const oldRow = Math.floor((pea.y + 0.5) / GRID_CELL_SIZE);
                preservedVisible.push({ x: pea.x, y: pea.y, col: pea.col, oldRow, colorIndex: pea.colorIndex, isGreen: pea.isGreen });
            }

            const settledSnapshot = settledPeas.slice();
            const activeSnapshot = peas.slice();

            settledSnapshot.forEach((pea, i) => {
                if (pea.y >= 0 && pea.y < visibleHeight) {
                    const colorIndex = pea.colorIndex !== undefined ? pea.colorIndex : (i % peaColors.length);
                    addPreserved({ ...pea, colorIndex });
                }
            });
            activeSnapshot.forEach((pea, i) => {
                if (pea.y >= 0 && pea.y < visibleHeight) {
                    const colorIndex = pea.colorIndex !== undefined ? pea.colorIndex : (i % peaColors.length);
                    addPreserved({ ...pea, colorIndex });
                }
            });

            peas = [];
            settledPeas = [];
            occupiedGrid.clear();

            const locked = new Set();

            for (const p of preservedVisible) {
                const newRow = p.oldRow + extraRowsAbove;
                const newY = newRow * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                const pea = {
                    x: p.x,
                    y: newY,
                    col: p.col,
                    row: newRow,
                    colorIndex: p.colorIndex,
                    settled: true,
                    isGreen: p.isGreen || false
                };
                settledPeas.push(pea);
                occupyGrid(p.col, newRow);
                locked.add(getGridKey(p.col, newRow));
            }

            for (let row = 0; row < extraRowsAbove; row++) {
                const flippedRow = extraRowsAbove - 1 - row;
                for (let col = 0; col < gridCols; col++) {
                    const key = getGridKey(col, flippedRow);
                    if (!locked.has(key)) {
                        const pea = {
                            x: col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                            y: flippedRow * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                            col,
                            row: flippedRow,
                            colorIndex: Math.floor(Math.random() * peaColors.length),
                            settled: true,
                            isGreen: false
                        };
                        settledPeas.push(pea);
                        occupyGrid(col, flippedRow);
                    }
                }
            }

            for (let row = extraRowsAbove; row < totalRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const key = getGridKey(col, row);
                    if (!locked.has(key)) {
                        const pea = {
                            x: col * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                            y: row * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
                            col,
                            row,
                            colorIndex: Math.floor(Math.random() * peaColors.length),
                            settled: true,
                            isGreen: false
                        };
                        settledPeas.push(pea);
                        occupyGrid(col, row);
                    }
                }
            }

            canvas.height = totalHeight;
            gridRows = totalRows;
            document.body.style.overflow = 'scroll';
            animationComplete = true;

            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            draw();
            ctx.putImageData(visibleSnapshot, 0, totalHeight - visibleHeight);

            const targetScrollY = document.documentElement.scrollHeight - window.innerHeight;
            window.scrollTo(0, targetScrollY);

            setTimeout(() => {
                scrollIndicator.textContent = 'Nach oben scrollen um deinen ganzen Reichtum zu entdecken';
                updateScrollIndicator();
            }, 100);
        }

        function lockMonthProgression(lock) {
            monthlyCompletionsLocked = lock;
            renderQuestions();
        }
 

        function handleMonthCompletion() {
            if (monthlyCompletionsLocked || heritageEventTriggered) return;
            if (currentMonthIndex >= 12) return;
            dismissTutorial();
            addMonthlyGreenPeas();
            yearlyPeasEarned += 9;
            currentMonthIndex++;
            updateQuestionStates();
 
            if (currentYear === 1 && currentMonthIndex >= 12) {

                lockMonthProgression(true);
                showTaxPopup();
            } else if (currentYear === 2 && currentMonthIndex >= 12 && !heritageEventTriggered) {
                lockMonthProgression(true);
                triggerHeritageEvent('december-teacher');
            }
        }

        function syncTutorialOverlay() {
            if (!tutorialOverlay) return;
            const content = tutorialMessages[tutorialPhase] || tutorialMessages[1];
            tutorialText.innerHTML = `<p>${content.text}</p>`;
            tutorialIcon.textContent = content.icon;
            tutorialOverlay.classList.toggle('visible', showTutorial);
            tutorialOverlay.setAttribute('aria-hidden', String(!showTutorial));
        }

        function dismissTutorial() {
            if (!showTutorial) return;
            showTutorial = false;
            syncTutorialOverlay();
        }

        function startTutorialPhase(phase) {
            tutorialPhase = phase;
            showTutorial = true;
            syncTutorialOverlay();
        }

        function showTaxPopup() {
            taxPopupStep = 1;
            taxPopupTitle.textContent = 'üèõÔ∏è Steueramt';
            taxPopupText.textContent = `Wir sehen, Sie haben dieses Jahr ${yearlyPeasEarned} Erbsen verdient. Daf√ºr haben Sie sicher hart gearbeitet?`;
            taxPopupButton.textContent = 'Ja';
            taxPopupButton.classList.remove('no-button');
            taxOverlay.classList.add('visible');
            taxPopup.classList.add('visible');
        }

        function showHeritagePopup() {
            taxPopupStep = 100;
            taxPopupTitle.textContent = 'üí∞ Erbs-schaft';
            taxPopupText.innerHTML = "Anruf von der Familie: Du erh√§lst eine <b>Erbs-schaft von 50 Millionen CHF</b> (50'000 Erbsen)";
            taxPopupButton.textContent = 'OK';
            taxPopupButton.classList.remove('no-button');
            taxOverlay.classList.add('visible');
            taxPopup.classList.add('visible');
        }

        function showPostCascadeTaxPopup() {
            taxPopupStep = 200;
            taxPopupTitle.textContent = 'üèõÔ∏è Steueramt';
            taxPopupText.textContent = "Wir sehen, Sie haben auf einen Schlag 50'000 Erbsen verdient. Daf√ºr haben Sie sicher hart gearbeitet?";
            taxPopupButton.textContent = 'Nein';
            taxPopupButton.classList.add('no-button');
            taxOverlay.classList.add('visible');
            taxPopup.classList.add('visible');
        }

        function triggerHeritageEvent() {
            if (heritageEventTriggered) return false;
            heritageEventTriggered = true;
            setTimeout(() => {
                showHeritagePopup();
            }, 500);
            return true;
        }

        function chargeIncomeTax(onComplete) {
            const greenPeas = settledPeas.filter(p => p.isGreen);
            if (greenPeas.length === 0) {
                onComplete?.();
                return;
            }

            greenPeas.sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row;
                return a.col - b.col;
            });

            const peasToRemove = greenPeas.slice(0, Math.min(18, greenPeas.length));
            const actualRemoveCount = peasToRemove.length;

            peasToRemove.forEach(pea => {
                pea.isBlinking = true;
                pea.blinkStartTime = performance.now();
            });

            erbsenNotification = {
                text: `-${actualRemoveCount} Erbsen`,
                opacity: 1,
                offsetY: 0,
                startTime: performance.now(),
                isNegative: true
            };

            setTimeout(() => {
                peasToRemove.forEach(pea => {
                    const index = settledPeas.indexOf(pea);
                    if (index > -1) {
                        settledPeas.splice(index, 1);
                        occupiedGrid.delete(getGridKey(pea.col, pea.row));
                    }
                });
                currentMoney -= actualRemoveCount * 1000;
                repositionGreenPeas();
                const remainingGreenPeas = settledPeas.filter(p => p.isGreen).length;
                greenPeaPlacementIndex = remainingGreenPeas;
                onComplete?.();
            }, RED_BLINK_TIME);
        }

        function prepareNextYear() {
            currentMonthIndex = 0;
            yearlyPeasEarned = 0;
            if (currentYear === 1) {
                currentYear = 2;
                startTutorialPhase(2);
            }
            examQuestions.forEach((question, idx) => {
                question.userEvaluation = null;
                question.state = idx === 0 ? 'active' : 'future';
            });
            lockMonthProgression(false);
            renderQuestions();
            draw();
        }

        function handleTaxPopupButton() {
            taxPopupButton.classList.remove('no-button');

            if (taxPopupStep === 100) {
                taxOverlay.classList.remove('visible');
                taxPopup.classList.remove('visible');
                taxPopupStep = 0;
                currentMoney += 50000000;
                manualMode = false;
                animationPaused = false;
                setQuestionBoardCascadeState(true);
                setTimeout(() => {
                    checkCascadeCompletion();
                }, 100);
            } else if (taxPopupStep === 200) {
                taxPopupStep = 201;
                taxPopupText.textContent = 'Achso... dann interessiert uns das nicht.';
                taxPopupButton.textContent = 'OK';
            } else if (taxPopupStep === 201) {
                taxOverlay.classList.remove('visible');
                taxPopup.classList.remove('visible');
                taxPopupStep = 0;
                allowResetButtonsReveal = true;
                allowScrollIndicatorReveal = true;
                updateScrollIndicator();
            } else if (taxPopupStep === 1) {
                taxPopupStep = 2;
                taxPopupText.innerHTML = 'Gerne verrechnen wir ihnen <b>18 Erbsen Einkommenssteuer (18\'000.-).</b> Sie werden direkt von ihrem Konto abgebucht.';
                taxPopupButton.textContent = 'OK';
            } else if (taxPopupStep === 2) {
                taxOverlay.classList.remove('visible');
                taxPopup.classList.remove('visible');
                taxPopupStep = 0;
                chargeIncomeTax(() => {
                    prepareNextYear();
                });
            }
        }

        function checkCascadeCompletion() {
            if (animationComplete) {
                if (!heritageEventTriggered) {
                    setQuestionBoardCascadeState(false);
                }
                document.body.style.overflow = 'hidden';
                setTimeout(() => {
                    showPostCascadeTaxPopup();
                    document.body.style.overflow = 'scroll';
                }, postCascadeTaxDelay);
            } else {
                setTimeout(() => {
                    checkCascadeCompletion();
                }, 100);
            }
        }

        function updateScrollIndicator() {
            if (!animationComplete || !allowScrollIndicatorReveal) {
                scrollIndicator.classList.add('hidden');
                return;
            }
            const scrollPosition = window.scrollY;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            if (scrollPosition < maxScroll - 100) {
                scrollIndicator.classList.add('hidden');
                restartBtn.style.visibility = 'visible';
                infoBtn.style.visibility = 'visible';
                requestAnimationFrame(() => {
                    restartBtn.style.opacity = '1';
                    infoBtn.style.opacity = '1';
                });
                resetButtonsShown = true;
            } else {
                scrollIndicator.classList.remove('hidden');
            }
        }

        function updateSimulation() {
            if (!animationComplete && !animationPaused) {
                if (!manualMode && isScreenFull()) {
                    animationPaused = true;
                    requestAnimationFrame(() => {
                        generateCompleteStack();
                    });
                    return;
                }
                frameCount++;
                if (!manualMode && spawnedCount < TOTAL_PEAS) {
                    spawnPeas();
                }
                const stillActive = [];
                for (let i = 0; i < peas.length; i++) {
                    const pea = peas[i];
                    pea.update();
                    if (pea.settled) {
                        settledPeas.push(pea);
                    } else {
                        stillActive.push(pea);
                    }
                }
                peas = stillActive;
            }
        }
 
        function draw() {

            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'rgba(30, 30, 30, 0.7)';
            ctx.fillRect(0, 0, canvas.width, TOP_BAR_HEIGHT);
            ctx.font = 'bold 18px Arial, sans-serif';
            ctx.textBaseline = 'middle';

            const iconFontSize = 26;
            const iconPadding = 14;
            const iconCenterY = TOP_BAR_HEIGHT / 2;
            const iconX = 20;
            const boundsSize = iconFontSize + iconPadding;
            menuButtonBounds = {
                x: iconX - iconPadding * 0.4,
                y: iconCenterY - boundsSize / 2,
                width: boundsSize,
                height: boundsSize
            };
            ctx.save();
            ctx.fillStyle = menuButtonHover ? '#A7E059' : '#7CB342';
            ctx.font = `bold ${iconFontSize}px Arial, sans-serif`;
            ctx.textAlign = 'left';
            ctx.fillText('<', iconX, iconCenterY);
            ctx.restore();

            ctx.fillStyle = '#7CB342';
            ctx.textAlign = 'center';
            ctx.fillText('Jahr ' + currentYear, canvas.width / 2, TOP_BAR_HEIGHT / 2);

            const greenArea = getGreenPeaArea();
            const bgStartY = greenArea.bgStartRow * GRID_CELL_SIZE;
 
            const bgEndY = greenArea.endRow * GRID_CELL_SIZE;

            const bgHeight = bgEndY - bgStartY;
            ctx.fillStyle = 'rgba(124, 179, 66, 0.15)';
            ctx.fillRect(0, bgStartY, canvas.width, bgHeight);

            const marginCols = 2;
            const labelX = canvas.width - (marginCols * GRID_CELL_SIZE);
            const labelY = bgStartY - 5;
            ctx.fillStyle = '#7CB342';
            ctx.font = '18px Arial, sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            ctx.fillText('Erbsen-Bank', labelX, labelY);

            (function drawMoneyCounter() {
                const moneyX = marginCols * GRID_CELL_SIZE;
                const moneyY = canvas.height - 20;
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial, sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(currentMoney.toLocaleString('de-CH') + '.-', moneyX, moneyY);
            })();

            (function drawPeaValueIndicator() {
                const peaX = canvas.width - 90;
                const peaY = canvas.height - 20;
                ctx.fillStyle = greenPeaColors[0];
                ctx.beginPath();
                ctx.arc(peaX, peaY, PEA_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial, sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText("= 1'000.-", peaX + PEA_RADIUS + 8, peaY);
            })();

            if (erbsenNotification) {
                const elapsed = performance.now() - erbsenNotification.startTime;
                const duration = 1000;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    erbsenNotification.offsetY = progress * 40;
                    erbsenNotification.opacity = 1 - progress;
                    ctx.save();
                    const color = erbsenNotification.isNegative ? '211, 47, 47' : '124, 179, 66';
                    ctx.fillStyle = `rgba(${color}, ${erbsenNotification.opacity})`;
                    ctx.font = 'bold 20px Arial, sans-serif';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'bottom';
                    const notificationX = marginCols * GRID_CELL_SIZE;
                    ctx.fillText(erbsenNotification.text, notificationX, labelY - erbsenNotification.offsetY);
                    ctx.restore();
                } else {
                    erbsenNotification = null;
                }
            }

            ctx.fillStyle = '#d32f2f';
            ctx.beginPath();
            for (let i = 0; i < settledPeas.length; i++) {
                const pea = settledPeas[i];
                if (pea.isBlinking) {
                    const elapsed = performance.now() - pea.blinkStartTime;
                    const blinkCycle = Math.floor(elapsed / 100);
                    if (blinkCycle % 2 === 0) {
                        ctx.moveTo(pea.x + PEA_RADIUS, pea.y);
                        ctx.arc(pea.x, pea.y, PEA_RADIUS, 0, Math.PI * 2);
                    }
                }
            }
            ctx.fill();

            for (let colorIdx = 0; colorIdx < greenPeaColors.length; colorIdx++) {
                ctx.fillStyle = greenPeaColors[colorIdx];
                ctx.beginPath();
                for (let i = 0; i < settledPeas.length; i++) {
                    const pea = settledPeas[i];
                    if (pea.isGreen) {
                        if (pea.isMoving) {
                            const elapsed = performance.now() - pea.moveStartTime;
                            const moveDuration = 300;
                            if (elapsed < moveDuration) {
                                const progress = elapsed / moveDuration;
                                const easeProgress = 1 - Math.pow(1 - progress, 3);
                                pea.x = pea.startX + (pea.targetX - pea.startX) * easeProgress;
                                pea.y = pea.startY + (pea.targetY - pea.startY) * easeProgress;
                            } else {
                                pea.x = pea.targetX;
                                pea.y = pea.targetY;
                                pea.col = pea.targetCol;
                                pea.row = pea.targetRow;
                                pea.isMoving = false;
                                occupyGrid(pea.col, pea.row);
                            }
                        }
                        if (pea.isBlinking) continue;
                        const peaColorIdx = pea.colorIndex !== undefined ? pea.colorIndex : i % greenPeaColors.length;
                        if (peaColorIdx === colorIdx) {
                            let radius = PEA_RADIUS;
                            if (pea.isPulsating && pea.pulseDuration > 0) {
                                const progress = Math.min(pea.pulseTime / pea.pulseDuration, 1);
                                const pulseScale = progress < 0.5 ? 0.5 + (progress * 2) * 0.8 : 1.3 - ((progress - 0.5) * 2) * 0.3;
                                radius = PEA_RADIUS * pulseScale;
                                radius = Math.max(0.1, radius);
                            }
                            ctx.moveTo(pea.x + radius, pea.y);
                            ctx.arc(pea.x, pea.y, radius, 0, Math.PI * 2);
                        }
                    }
                }
                for (let i = 0; i < peas.length; i++) {
                    const pea = peas[i];
                    if (pea.isGreen) {
                        const peaColorIdx = pea.colorIndex !== undefined ? pea.colorIndex : i % greenPeaColors.length;
                        if (peaColorIdx === colorIdx) {
                            ctx.moveTo(pea.x + PEA_RADIUS, pea.y);
                            ctx.arc(pea.x, pea.y, PEA_RADIUS, 0, Math.PI * 2);
                        }
                    }
                }
                ctx.fill();
            }

            for (let colorIdx = 0; colorIdx < peaColors.length; colorIdx++) {
                ctx.fillStyle = peaColors[colorIdx];
                ctx.beginPath();
                for (let i = 0; i < settledPeas.length; i++) {
                    const pea = settledPeas[i];
                    if (!pea.isGreen) {
                        const peaColorIdx = pea.colorIndex !== undefined ? pea.colorIndex : i % peaColors.length;
                        if (peaColorIdx === colorIdx) {
                            ctx.moveTo(pea.x + PEA_RADIUS, pea.y);
                            ctx.arc(pea.x, pea.y, PEA_RADIUS, 0, Math.PI * 2);
                        }
                    }
                }
                for (let i = 0; i < peas.length; i++) {
                    const pea = peas[i];
                    if (!pea.isGreen && i % peaColors.length === colorIdx) {
                        ctx.moveTo(pea.x + PEA_RADIUS, pea.y);
                        ctx.arc(pea.x, pea.y, PEA_RADIUS, 0, Math.PI * 2);
                    }
                }
                ctx.fill();
            }

            if (animationComplete) {
                const rowsPer10k = Math.floor(10000 / gridCols);
                ctx.strokeStyle = 'rgba(0,0,0,0.75)';
                ctx.lineWidth = 5;
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                for (let row = rowsPer10k; row < (gridRows - rowsPer10k); row += rowsPer10k) {
                    const y = (gridRows - row) * GRID_CELL_SIZE;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                    const peasAtThisLine = row * gridCols;
                    const rounded = Math.round(peasAtThisLine / 10000) * 10000;
                    const label = rounded.toLocaleString('de-CH');
                    const paddingX = 6;
                    const paddingY = 2;
                    const textWidth = ctx.measureText(label).width;
                    const boxX = 5 - paddingX;
                    const boxY = y - (16 + paddingY * 2);
                    const boxWidth = textWidth + paddingX * 2;
                    const boxHeight = 16 + paddingY * 2;
                    ctx.fillStyle = 'rgba(0,0,0,0.75)';
                    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                    ctx.fillStyle = 'rgba(255,255,255,1)';
                    ctx.fillText(label, 5, y - 10);
                }
            }
        }

        function animate() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            const shouldTick = !animationComplete && deltaTime >= FRAME_INTERVAL;
            const needsPassiveDraw = erbsenNotification || showTutorial;
 
            if (shouldTick) {

                // Keep any leftover ms so the drift stays small
                lastFrameTime = currentTime - (deltaTime % FRAME_INTERVAL);
            }

            if (shouldTick || needsPassiveDraw) {
                frameDeltaSeconds = Math.min(0.1, (currentTime - lastDrawTime) / 1000);
                lastDrawTime = currentTime;
                updateSimulation();
                draw();
            } 

            requestAnimationFrame(animate);
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top + window.scrollY
            };
        }

        function isPointInMenuButton(x, y) {
            const b = menuButtonBounds;
            return x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height;
        }

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            const overMenuButton = isPointInMenuButton(pos.x, pos.y);
            const previousHover = menuButtonHover;
            menuButtonHover = overMenuButton;
            if (previousHover !== menuButtonHover) {
                draw();
            }
        });

        canvas.addEventListener('click', (e) => {
            const pos = getMousePos(e);
            if (isPointInMenuButton(pos.x, pos.y)) {
                window.location.href = 'index.html';
            }
        });

        window.addEventListener('resize', () => {
            if (!animationComplete) {
                resetCanvasToViewport();
                gridCols = calcGridCols();
                gridRows = calcGridRows();
            }
            syncQuestionBoardWindow();
            draw();
        });

        window.addEventListener('scroll', () => {
            updateScrollIndicator();
        });

        taxPopupButton.addEventListener('click', handleTaxPopupButton);
        restartBtn.addEventListener('click', () => {
            window.location.href = 'index.html';
        });
        infoBtn.addEventListener('click', () => {
            window.location.href = 'info.html';
        });

        document.body.style.overflow = 'hidden';
        window.scrollTo({ top: 0, behavior: 'auto' });
        scrollIndicator.classList.add('hidden');

        draw();
        animate();
    </script>
</body>
</html>